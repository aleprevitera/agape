<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz SSM - Specializzazioni Mediche</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #f5f5f5;
            color: #1a1a1a;
            line-height: 1.5;
            min-height: 100vh;
        }
        .container { max-width: 720px; margin: 0 auto; padding: 24px 16px; }
        header { margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #e0e0e0; }
        header h1 { font-size: 1.25rem; font-weight: 600; margin-bottom: 4px; }
        .stats { font-size: 0.875rem; color: #666; }
        .materia-tag { display: inline-block; background: #e8f4fd; color: #0969da; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-left: 8px; }
        .progress-bar { height: 3px; background: #e0e0e0; margin-top: 12px; border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: #1a1a1a; transition: width 0.3s ease; }
        .question-card { background: #fff; border-radius: 8px; padding: 24px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); margin-bottom: 16px; }
        .question-number { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; margin-bottom: 8px; }
        .question-text { font-size: 1.125rem; font-weight: 500; margin-bottom: 20px; }
        .options { display: flex; flex-direction: column; gap: 8px; }
        .option { padding: 14px 16px; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; transition: all 0.15s ease; font-size: 0.9375rem; text-align: left; background: #fff; }
        .option:hover:not(.disabled) { border-color: #999; background: #fafafa; }
        .option.correct { border-color: #22863a; background: #dcffe4; color: #22863a; }
        .option.wrong { border-color: #cb2431; background: #ffeef0; color: #cb2431; }
        .option.show-correct { border-color: #22863a; background: #dcffe4; }
        .option.disabled { cursor: default; }
        .feedback { margin-top: 16px; padding: 12px 16px; border-radius: 6px; font-size: 0.875rem; display: none; }
        .feedback.visible { display: block; }
        .feedback.correct { background: #dcffe4; color: #22863a; }
        .feedback.wrong { background: #ffeef0; color: #cb2431; }
        .commento { margin-top: 12px; padding: 12px 16px; background: #f6f8fa; border-radius: 6px; font-size: 0.875rem; color: #444; display: none; }
        .commento.visible { display: block; }
        .commento strong { color: #1a1a1a; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 0.9375rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
        .btn-primary { background: linear-gradient(135deg, #1a1a1a 0%, #333 100%); color: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .btn-primary:hover { background: linear-gradient(135deg, #333 0%, #444 100%); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.25); }
        .btn-secondary { background: #fff; color: #1a1a1a; border: 1px solid #e0e0e0; }
        .btn-secondary:hover { background: #f5f5f5; border-color: #ccc; }
        .btn-danger { background: #cb2431; color: #fff; }
        .btn-danger:hover { background: #a51d28; }
        .btn-small { padding: 8px 16px; font-size: 0.8125rem; }
        .actions { display: flex; gap: 12px; margin-top: 20px; }
        .results { text-align: center; padding: 48px 24px; }
        .results h2 { font-size: 1.75rem; margin-bottom: 8px; }
        .score { font-size: 3rem; font-weight: 700; margin: 24px 0; }
        .score-label { color: #666; font-size: 0.875rem; }
        .results-breakdown { display: flex; justify-content: center; gap: 32px; margin: 24px 0; padding: 20px; background: #f5f5f5; border-radius: 8px; }
        .breakdown-item { text-align: center; }
        .breakdown-value { font-size: 1.5rem; font-weight: 600; }
        .breakdown-label { font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 0.05em; }
        .start-screen { text-align: center; padding: 32px 24px; }
        .start-screen h1 { font-size: 1.875rem; margin-bottom: 8px; background: linear-gradient(135deg, #1a1a1a 0%, #444 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .start-screen .subtitle { color: #666; margin-bottom: 28px; font-size: 0.9375rem; }
        .mode-select { display: flex; flex-direction: column; gap: 8px; max-width: 420px; margin: 0 auto 28px; }
        .mode-section { margin-bottom: 16px; display: flex; flex-direction: column; gap: 8px; }
        .mode-section-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.1em; color: #888; margin-bottom: 10px; padding-left: 4px; display: flex; align-items: center; gap: 8px; }
        .mode-section-title::after { content: ''; flex: 1; height: 1px; background: #e0e0e0; }
        .mode-option { padding: 14px 16px; border: 2px solid #e0e0e0; border-radius: 12px; cursor: pointer; transition: all 0.2s ease; text-align: left; background: #fff; display: flex; align-items: center; gap: 14px; }
        .mode-option:hover:not(.disabled) { border-color: #bbb; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .mode-option.selected { border-color: #1a1a1a; background: linear-gradient(135deg, #f8f8f8 0%, #fff 100%); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .mode-option.disabled { opacity: 0.4; pointer-events: none; }
        .mode-option-icon { width: 44px; height: 44px; border-radius: 10px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .mode-option-icon svg { width: 24px; height: 24px; }
        .mode-option-content { flex: 1; min-width: 0; }
        .mode-option-content strong { display: block; margin-bottom: 2px; font-size: 0.9375rem; }
        .mode-option-content span { font-size: 0.8125rem; color: #666; display: block; }
        .mode-option-badge { font-size: 0.6875rem; padding: 3px 8px; border-radius: 10px; font-weight: 600; flex-shrink: 0; }
        /* Icon backgrounds */
        .mode-option[data-mode="140"] .mode-option-icon { background: linear-gradient(135deg, #1a1a1a 0%, #333 100%); color: #fff; }
        .mode-option[data-mode="20"] .mode-option-icon { background: linear-gradient(135deg, #22863a 0%, #2ea043 100%); color: #fff; }
        .mode-option[data-mode="custom"] .mode-option-icon { background: linear-gradient(135deg, #6f42c1 0%, #8957e5 100%); color: #fff; }
        .mode-option[data-mode="wrong"] .mode-option-icon { background: linear-gradient(135deg, #dbab09 0%, #f0c000 100%); color: #fff; }
        .mode-option[data-mode="weak"] .mode-option-icon { background: linear-gradient(135deg, #cb2431 0%, #d73a49 100%); color: #fff; }
        .mode-option[data-mode="shared-create"] .mode-option-icon { background: linear-gradient(135deg, #0969da 0%, #2188ff 100%); color: #fff; }
        .mode-option[data-mode="shared-join"] .mode-option-icon { background: linear-gradient(135deg, #0969da 0%, #2188ff 100%); color: #fff; }
        .mode-option:active:not(.disabled) { transform: scale(0.98); }
        .btn:active { transform: scale(0.97); }
        .hidden { display: none !important; }
        .review-section { margin-top: 32px; text-align: left; }
        .review-section h3 { font-size: 1rem; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0; }
        .review-item { padding: 16px; background: #fff; border-radius: 6px; margin-bottom: 12px; border-left: 3px solid #cb2431; }
        .review-question { font-weight: 500; margin-bottom: 8px; font-size: 0.9375rem; }
        .review-materia { font-size: 0.75rem; color: #0969da; margin-bottom: 8px; }
        .review-your { font-size: 0.8125rem; color: #cb2431; margin-bottom: 4px; }
        .review-correct { font-size: 0.8125rem; color: #22863a; margin-bottom: 8px; }
        .review-commento { font-size: 0.8125rem; color: #666; padding-top: 8px; border-top: 1px solid #eee; }
        .loading { text-align: center; padding: 80px 24px; color: #666; }
        .error-screen { text-align: center; padding: 80px 24px; }
        .error-screen p { color: #cb2431; margin-bottom: 16px; }
        .materie-filter { margin-top: 24px; padding: 16px; background: #fff; border-radius: 8px; text-align: left; }
        .materie-filter h4 { font-size: 0.875rem; margin-bottom: 12px; }
        .materie-grid { display: flex; flex-wrap: wrap; gap: 6px; max-height: 200px; overflow-y: auto; }
        .materia-chip { padding: 4px 10px; border: 1px solid #e0e0e0; border-radius: 16px; font-size: 0.75rem; cursor: pointer; transition: all 0.15s ease; }
        .materia-chip:hover { border-color: #999; }
        .materia-chip.selected { background: #1a1a1a; color: #fff; border-color: #1a1a1a; }
        .filter-actions { margin-top: 12px; display: flex; gap: 8px; }
        .filter-actions button { font-size: 0.75rem; padding: 4px 8px; }
        .question-image { margin: 16px 0; text-align: center; }
        .question-image img { max-width: 100%; max-height: 300px; border-radius: 6px; cursor: pointer; border: 1px solid #e0e0e0; }
        .question-image img:hover { border-color: #999; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; justify-content: center; align-items: center; }
        .modal.visible { display: flex; }
        .modal img { max-width: 95%; max-height: 95%; object-fit: contain; }
        .modal-close { position: absolute; top: 20px; right: 30px; color: #fff; font-size: 2rem; cursor: pointer; }
        .review-image { margin: 8px 0; }
        .review-image img { max-width: 100%; max-height: 150px; border-radius: 4px; }

        /* Stats styles */
        .stats-screen { padding: 24px 0; }
        .stats-screen h1 { font-size: 1.5rem; margin-bottom: 8px; text-align: center; }
        .stats-screen .subtitle { color: #666; margin-bottom: 24px; text-align: center; font-size: 0.875rem; }
        .stats-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
        .stats-summary-item { background: #fff; padding: 16px; border-radius: 8px; text-align: center; }
        .stats-summary-value { font-size: 1.5rem; font-weight: 700; }
        .stats-summary-label { font-size: 0.75rem; color: #666; text-transform: uppercase; }
        .stats-section { background: #fff; border-radius: 8px; padding: 20px; margin-bottom: 16px; }
        .stats-section h3 { font-size: 1rem; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; }
        .stats-section h3 .toggle { font-size: 0.75rem; color: #0969da; cursor: pointer; }
        .stat-row { display: flex; align-items: center; gap: 12px; padding: 10px 0; border-bottom: 1px solid #f0f0f0; }
        .stat-row:last-child { border-bottom: none; }
        .stat-name { flex: 1; font-size: 0.875rem; min-width: 0; }
        .stat-name span { display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .stat-bar-container { width: 120px; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; }
        .stat-bar { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .stat-bar.good { background: #22863a; }
        .stat-bar.medium { background: #dbab09; }
        .stat-bar.bad { background: #cb2431; }
        .stat-value { width: 60px; text-align: right; font-size: 0.8125rem; font-weight: 500; }
        .stat-count { width: 40px; text-align: right; font-size: 0.75rem; color: #888; }
        .weak-areas { background: #ffeef0; border: 1px solid #ffcdd2; border-radius: 8px; padding: 16px; margin-bottom: 24px; }
        .weak-areas h3 { color: #cb2431; font-size: 0.875rem; margin-bottom: 12px; }
        .weak-areas ul { list-style: none; }
        .weak-areas li { padding: 6px 0; font-size: 0.875rem; border-bottom: 1px solid #ffcdd2; display: flex; justify-content: space-between; }
        .weak-areas li:last-child { border-bottom: none; }
        .weak-areas .weak-pct { color: #cb2431; font-weight: 500; }
        .no-stats { text-align: center; padding: 40px; color: #888; }
        .argomenti-list { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .argomenti-list.expanded { max-height: 1000px; }
        .argomenti-list .stat-row { padding-left: 16px; background: #fafafa; }
        .argomenti-list .stat-name { font-size: 0.8125rem; color: #666; }
        .practice-weak-btn { margin-top: 12px; }

        /* Timer styles */
        .timer { font-size: 1rem; font-weight: 600; padding: 8px 16px; background: #f5f5f5; border-radius: 6px; display: inline-flex; align-items: center; gap: 8px; }
        .timer.warning { background: #fff3cd; color: #856404; }
        .timer.danger { background: #ffeef0; color: #cb2431; animation: pulse 1s infinite; }
        .timer-icon { width: 16px; height: 16px; }
        .option.selected { border-color: #0969da; background: #e8f4fd; color: #0969da; }
        .question-nav-btn { width: 32px; height: 32px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fff; cursor: pointer; font-size: 0.75rem; transition: all 0.15s; }
        .question-nav-btn:hover { border-color: #999; }
        .question-nav-btn.current { border-color: #0969da; background: #e8f4fd; color: #0969da; font-weight: 600; }
        .question-nav-btn.answered { background: #1a1a1a; color: #fff; border-color: #1a1a1a; }
        .question-nav-btn.answered.current { background: #0969da; border-color: #0969da; }

        /* Simulation history styles */
        .simulations-section { margin-top: 24px; }
        .simulations-section h3 { font-size: 1rem; margin-bottom: 16px; }
        .simulation-cards { display: flex; flex-direction: column; gap: 12px; }
        .simulation-card { background: #fff; border-radius: 8px; padding: 16px; border: 1px solid #e0e0e0; cursor: pointer; transition: all 0.15s; }
        .simulation-card:hover { border-color: #999; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        .simulation-card.expanded { border-color: #0969da; }
        .simulation-header { display: flex; justify-content: space-between; align-items: center; }
        .simulation-date { font-size: 0.875rem; color: #666; }
        .simulation-score { font-size: 1.25rem; font-weight: 700; }
        .simulation-score.good { color: #22863a; }
        .simulation-score.medium { color: #dbab09; }
        .simulation-score.bad { color: #cb2431; }
        .simulation-stats { display: flex; gap: 16px; margin-top: 8px; font-size: 0.8125rem; color: #666; }
        .simulation-details { margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0; display: none; }
        .simulation-card.expanded .simulation-details { display: block; }
        .simulation-breakdown { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
        .breakdown-row { display: flex; justify-content: space-between; font-size: 0.8125rem; padding: 4px 0; }
        .breakdown-row .materia-name { color: #666; }
        .breakdown-row .materia-score { font-weight: 500; }
        .no-simulations { text-align: center; padding: 32px; color: #888; font-size: 0.875rem; }

        /* Projected Score KPI */
        .kpi-main { background: linear-gradient(135deg, #1a1a1a 0%, #333 100%); color: #fff; border-radius: 12px; padding: 24px; margin-bottom: 24px; text-align: center; }
        .kpi-main .kpi-label { font-size: 0.875rem; opacity: 0.8; margin-bottom: 8px; }
        .kpi-main .kpi-value { font-size: 3rem; font-weight: 700; line-height: 1; }
        .kpi-main .kpi-max { font-size: 1.25rem; opacity: 0.6; }
        .kpi-main .kpi-subtitle { font-size: 0.75rem; opacity: 0.6; margin-top: 8px; }
        .kpi-secondary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
        .kpi-card { background: #fff; border-radius: 8px; padding: 16px; text-align: center; border: 1px solid #e0e0e0; }
        .kpi-card .value { font-size: 1.5rem; font-weight: 600; }
        .kpi-card .label { font-size: 0.75rem; color: #666; margin-top: 4px; }
        .kpi-card.trend-up .value { color: #22863a; }
        .kpi-card.trend-down .value { color: #cb2431; }

        /* Chart container */
        .chart-container { background: #fff; border-radius: 8px; padding: 20px; margin-bottom: 24px; border: 1px solid #e0e0e0; }
        .chart-container h3 { font-size: 1rem; margin-bottom: 16px; }
        .chart-wrapper { position: relative; height: 200px; }
        .no-chart-data { text-align: center; padding: 60px 20px; color: #888; font-size: 0.875rem; }

        /* Stats tabs */
        .stats-tabs { display: flex; gap: 4px; margin-bottom: 16px; border-bottom: 1px solid #e0e0e0; padding-bottom: 0; }
        .stats-tab { padding: 12px 20px; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: #666; border-bottom: 2px solid transparent; margin-bottom: -1px; transition: all 0.15s; }
        .stats-tab:hover { color: #1a1a1a; }
        .stats-tab.active { color: #1a1a1a; font-weight: 500; border-bottom-color: #1a1a1a; }
        .stats-tab-content { display: none; }
        .stats-tab-content.active { display: block; }

        /* Auth styles */
        .auth-header { display: flex; justify-content: flex-end; padding: 12px 0; margin-bottom: 8px; }
        .auth-btn { display: flex; align-items: center; gap: 8px; padding: 8px 16px; border: 1px solid #e0e0e0; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.875rem; transition: all 0.15s ease; }
        .auth-btn:hover { background: #f5f5f5; border-color: #999; }
        .auth-btn img { width: 18px; height: 18px; }
        .auth-btn.logout { border-color: #ffcdd2; color: #cb2431; }
        .auth-btn.logout:hover { background: #ffeef0; }
        .user-info { display: flex; align-items: center; gap: 12px; }
        .user-email { font-size: 0.8125rem; color: #666; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .sync-indicator { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: #888; }
        .sync-indicator.syncing { color: #0969da; }
        .sync-indicator.synced { color: #22863a; }
        .sync-indicator.offline { color: #cb2431; }
        .sync-dot { width: 8px; height: 8px; border-radius: 50%; background: currentColor; }
        .sync-indicator.syncing .sync-dot { animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .google-icon { width: 18px; height: 18px; }

        /* Shared session styles */
        .lobby-screen { text-align: center; padding: 24px; }
        .lobby-screen h1 { font-size: 1.75rem; margin-bottom: 8px; }
        .lobby-screen .subtitle { color: #666; margin-bottom: 24px; }
        .session-code { font-size: 2.5rem; font-weight: 700; letter-spacing: 0.3em; background: #1a1a1a; color: #fff; padding: 16px 32px; border-radius: 12px; display: inline-block; margin: 16px 0; font-family: monospace; }
        .session-code-label { font-size: 0.875rem; color: #666; margin-bottom: 8px; }
        .participant-list { background: #fff; border-radius: 8px; padding: 16px; margin: 24px 0; border: 1px solid #e0e0e0; text-align: left; max-height: 300px; overflow-y: auto; }
        .participant-list h3 { font-size: 0.875rem; color: #666; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em; }
        .participant-item { display: flex; align-items: center; gap: 12px; padding: 10px 0; border-bottom: 1px solid #f0f0f0; }
        .participant-item:last-child { border-bottom: none; }
        .participant-avatar { width: 36px; height: 36px; border-radius: 50%; background: #e8f4fd; display: flex; align-items: center; justify-content: center; font-weight: 600; color: #0969da; font-size: 0.875rem; }
        .participant-name { flex: 1; font-weight: 500; }
        .participant-host { font-size: 0.75rem; color: #0969da; background: #e8f4fd; padding: 2px 8px; border-radius: 10px; }
        .participant-status { font-size: 0.75rem; color: #22863a; }
        .participant-status.completed { color: #22863a; font-weight: 500; }
        .participant-status.in-progress { color: #dbab09; }
        .waiting-animation { display: flex; justify-content: center; gap: 6px; margin: 16px 0; }
        .waiting-dot { width: 10px; height: 10px; background: #0969da; border-radius: 50%; animation: waitingPulse 1.4s infinite ease-in-out; }
        .waiting-dot:nth-child(2) { animation-delay: 0.2s; }
        .waiting-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes waitingPulse { 0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; } 40% { transform: scale(1); opacity: 1; } }
        .join-input { font-size: 1.5rem; text-align: center; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px; border: 2px solid #e0e0e0; border-radius: 8px; width: 200px; font-family: monospace; }
        .join-input:focus { outline: none; border-color: #0969da; }
        .leaderboard { background: #fff; border-radius: 12px; padding: 20px; margin: 24px 0; border: 1px solid #e0e0e0; }
        .leaderboard h3 { font-size: 1rem; margin-bottom: 16px; text-align: center; }
        .leaderboard-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; margin-bottom: 8px; }
        .leaderboard-item:nth-child(1) { background: linear-gradient(135deg, #ffd700 0%, #fff8dc 100%); }
        .leaderboard-item:nth-child(2) { background: linear-gradient(135deg, #c0c0c0 0%, #f5f5f5 100%); }
        .leaderboard-item:nth-child(3) { background: linear-gradient(135deg, #cd7f32 0%, #f5e6d3 100%); }
        .leaderboard-item:nth-child(n+4) { background: #f5f5f5; }
        .leaderboard-rank { font-size: 1.25rem; font-weight: 700; width: 32px; text-align: center; }
        .leaderboard-user { flex: 1; }
        .leaderboard-user-name { font-weight: 500; }
        .leaderboard-user-stats { font-size: 0.75rem; color: #666; }
        .leaderboard-score { font-size: 1.25rem; font-weight: 700; }
        .leaderboard-score.good { color: #22863a; }
        .leaderboard-score.medium { color: #dbab09; }
        .leaderboard-score.bad { color: #cb2431; }
        .session-info { background: #f5f5f5; border-radius: 8px; padding: 16px; margin: 16px 0; }
        .session-info-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.875rem; }
        .session-info-label { color: #666; }
        .session-info-value { font-weight: 500; }

        @media (max-width: 480px) {
            .container { padding: 16px 12px; }
            .question-card { padding: 20px 16px; }
            .results-breakdown { flex-direction: column; gap: 16px; }
            .start-screen h1 { font-size: 1.5rem; }
            .stats-summary { grid-template-columns: 1fr; }
            .stat-bar-container { width: 80px; }
            .user-email { max-width: 100px; }
        }
    </style>
</head>
<body>
    <div class="container" id="app">
        <div class="loading">Caricamento domande...</div>
    </div>

    <script>
    (function() {
        const app = document.getElementById('app');
        let questions = [];
        let materie = [];
        let argomenti = {};
        let quiz = null;
        let wrongIds = [];
        let selectedMaterie = [];
        let statsData = { materie: {}, argomenti: {} };

        const STORAGE_KEY = 'quiz_ssm_wrong';
        const STATS_KEY = 'quiz_ssm_stats';
        const SIMULATIONS_KEY = 'quiz_ssm_simulations';
        const PROJECTION_HISTORY_KEY = 'quiz_ssm_projection_history';

        let simulations = [];
        let projectionHistory = []; // Array of {date, projectedScore}

        // Supabase configuration
        const SUPABASE_URL = 'https://obckabzhhzcpxajaxxjo.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_Nv_TRfwJuYUJ9gB-m6EKCA_Xfc_PX13';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        let currentUser = null;
        let isAuthorized = false;
        let syncStatus = 'offline'; // 'offline', 'syncing', 'synced'
        let syncTimeout = null;
        let timerInterval = null;
        let initialSyncDone = false; // Block outgoing sync until we've loaded from cloud

        // Shared session variables
        let sharedSession = null;      // Current shared session data
        let sessionChannel = null;     // Supabase Realtime channel
        let sessionParticipants = [];  // List of participants
        let lobbyPollInterval = null;  // Fallback polling for lobby updates

        // Auth functions
        async function checkAuthorization(email) {
            try {
                const { data, error } = await supabase
                    .from('authorized_users')
                    .select('email')
                    .eq('email', email.toLowerCase())
                    .single();

                if (error && error.code !== 'PGRST116') {
                    console.error('Authorization check error:', error);
                    return false;
                }
                return !!data;
            } catch (err) {
                console.error('Authorization check failed:', err);
                return false;
            }
        }

        async function initAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            if (session) {
                currentUser = session.user;
                isAuthorized = await checkAuthorization(currentUser.email);
                if (isAuthorized) {
                    await syncFromCloud();
                }
            }

            supabase.auth.onAuthStateChange(async (event, session) => {
                if (event === 'SIGNED_IN' && session) {
                    currentUser = session.user;
                    isAuthorized = await checkAuthorization(currentUser.email);
                    if (isAuthorized) {
                        await syncFromCloud();
                        showStart();
                    } else {
                        showUnauthorized();
                    }
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    isAuthorized = false;
                    syncStatus = 'offline';
                    showLoginRequired();
                }
            });
        }

        async function loginWithGoogle() {
            const { error } = await supabase.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: window.location.origin + window.location.pathname
                }
            });
            if (error) {
                console.error('Login error:', error);
                alert('Errore durante il login: ' + error.message);
            }
        }

        async function logout() {
            await supabase.auth.signOut();
            currentUser = null;
            isAuthorized = false;
            syncStatus = 'offline';
            initialSyncDone = false;
        }

        function showLoginRequired() {
            render(`
                <div class="start-screen" style="text-align:center;">
                    <h1>Simulatore SSM</h1>
                    <p class="subtitle">Quiz di preparazione alle Specializzazioni Mediche</p>
                    <div style="margin:48px 0;padding:32px;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.1);">
                        <p style="margin-bottom:24px;color:#666;">Accedi per utilizzare il simulatore</p>
                        <button class="auth-btn" onclick="window.doLogin()" style="margin:0 auto;display:flex;">
                            <svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                            Accedi con Google
                        </button>
                    </div>
                    <p style="font-size:0.8rem;color:#888;">${questions.length} domande disponibili</p>
                </div>
            `);
        }

        function showUnauthorized() {
            render(`
                <div class="start-screen" style="text-align:center;">
                    <h1>Accesso non autorizzato</h1>
                    <div style="margin:48px 0;padding:32px;background:#fff;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,0.1);">
                        <p style="margin-bottom:16px;color:#666;">Hai effettuato l'accesso come:</p>
                        <p style="font-weight:600;margin-bottom:24px;">${currentUser ? currentUser.email : ''}</p>
                        <p style="color:#cb2431;margin-bottom:24px;">Questo account non Ã¨ autorizzato ad utilizzare il simulatore.</p>
                        <p style="font-size:0.875rem;color:#888;margin-bottom:24px;">Contatta l'amministratore per richiedere l'accesso.</p>
                        <button class="auth-btn logout" onclick="window.doLogout()" style="margin:0 auto;display:flex;">Esci</button>
                    </div>
                </div>
            `);
        }

        // Sync functions
        async function syncFromCloud() {
            if (!currentUser) return;

            syncStatus = 'syncing';
            updateSyncIndicator();

            try {
                const { data, error } = await supabase
                    .from('user_progress')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .single();

                if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
                    throw error;
                }

                if (data) {
                    // Cloud is source of truth - REPLACE local data (no merge)
                    statsData = data.stats_data || { materie: {}, argomenti: {} };
                    wrongIds = data.wrong_ids || [];
                    simulations = data.simulations || [];
                    projectionHistory = data.projection_history || [];

                    // Save to localStorage as cache
                    localStorage.setItem(STATS_KEY, JSON.stringify(statsData));
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(wrongIds));
                    localStorage.setItem(SIMULATIONS_KEY, JSON.stringify(simulations));
                    localStorage.setItem(PROJECTION_HISTORY_KEY, JSON.stringify(projectionHistory));
                }

                syncStatus = 'synced';
            } catch (err) {
                console.error('Sync from cloud error:', err);
                syncStatus = 'offline';
                // If cloud fails, keep using local data as fallback
            }

            initialSyncDone = true; // Now allow outgoing syncs
            updateSyncIndicator();
        }

        async function syncToCloud() {
            if (!currentUser) return;

            try {
                // Try full sync first
                const { error } = await supabase
                    .from('user_progress')
                    .upsert({
                        user_id: currentUser.id,
                        stats_data: statsData,
                        wrong_ids: wrongIds,
                        simulations: simulations,
                        projection_history: projectionHistory,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'user_id' });

                if (error) {
                    // If error (possibly missing columns), try basic sync
                    console.warn('Full sync failed, trying basic sync:', error.message);
                    const { error: basicError } = await supabase
                        .from('user_progress')
                        .upsert({
                            user_id: currentUser.id,
                            stats_data: statsData,
                            wrong_ids: wrongIds,
                            updated_at: new Date().toISOString()
                        }, { onConflict: 'user_id' });

                    if (basicError) throw basicError;
                }
                syncStatus = 'synced';
            } catch (err) {
                console.error('Sync to cloud error:', err);
                syncStatus = 'offline';
            }

            updateSyncIndicator();
        }

        function debouncedSync() {
            if (!currentUser) return;
            if (!initialSyncDone) return; // Don't sync TO cloud until we've loaded FROM cloud

            if (syncTimeout) clearTimeout(syncTimeout);
            syncStatus = 'syncing';
            updateSyncIndicator();

            syncTimeout = setTimeout(() => {
                syncToCloud();
            }, 2000); // Wait 2 seconds before syncing
        }

        function mergeStats(local, cloud) {
            const merged = { materie: {}, argomenti: {} };

            // Merge materie
            const allMaterie = new Set([...Object.keys(local.materie || {}), ...Object.keys(cloud.materie || {})]);
            allMaterie.forEach(m => {
                const localM = (local.materie || {})[m] || { correct: 0, total: 0 };
                const cloudM = (cloud.materie || {})[m] || { correct: 0, total: 0 };
                merged.materie[m] = {
                    correct: Math.max(localM.correct, cloudM.correct),
                    total: Math.max(localM.total, cloudM.total)
                };
            });

            // Merge argomenti
            const allArg = new Set([...Object.keys(local.argomenti || {}), ...Object.keys(cloud.argomenti || {})]);
            allArg.forEach(a => {
                const localA = (local.argomenti || {})[a] || { correct: 0, total: 0, materia: '', argomento: '' };
                const cloudA = (cloud.argomenti || {})[a] || { correct: 0, total: 0, materia: '', argomento: '' };
                merged.argomenti[a] = {
                    correct: Math.max(localA.correct, cloudA.correct),
                    total: Math.max(localA.total, cloudA.total),
                    materia: localA.materia || cloudA.materia,
                    argomento: localA.argomento || cloudA.argomento
                };
            });

            return merged;
        }

        function mergeWrongIds(local, cloud) {
            return [...new Set([...local, ...cloud])];
        }

        function mergeSimulations(local, cloud) {
            // Merge by id, keeping unique simulations, sorted by date descending
            const byId = new Map();
            [...local, ...cloud].forEach(sim => {
                if (!byId.has(sim.id)) {
                    byId.set(sim.id, sim);
                }
            });
            return Array.from(byId.values())
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 50); // Keep max 50
        }

        function mergeProjectionHistory(local, cloud) {
            // Merge by date, keeping unique entries, sorted chronologically
            const byDate = new Map();
            [...local, ...cloud].forEach(p => {
                const key = p.date;
                if (!byDate.has(key)) {
                    byDate.set(key, p);
                }
            });
            return Array.from(byDate.values())
                .sort((a, b) => new Date(a.date) - new Date(b.date))
                .slice(-100); // Keep last 100
        }

        function updateSyncIndicator() {
            const indicator = document.getElementById('sync-indicator');
            if (!indicator) return;

            indicator.className = 'sync-indicator ' + syncStatus;
            const labels = { offline: 'Offline', syncing: 'Sincronizzando...', synced: 'Sincronizzato' };
            indicator.innerHTML = `<span class="sync-dot"></span>${labels[syncStatus]}`;
        }

        function getAuthHeaderHtml() {
            if (currentUser) {
                return `
                    <div class="auth-header">
                        <div class="user-info">
                            <span id="sync-indicator" class="sync-indicator ${syncStatus}">
                                <span class="sync-dot"></span>${syncStatus === 'synced' ? 'Sincronizzato' : syncStatus === 'syncing' ? 'Sincronizzando...' : 'Offline'}
                            </span>
                            <span class="user-email" title="${currentUser.email}">${currentUser.email}</span>
                            <button class="auth-btn logout" onclick="window.doLogout()">Esci</button>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="auth-header">
                        <button class="auth-btn" onclick="window.doLogin()">
                            <svg class="google-icon" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                            Accedi con Google
                        </button>
                    </div>
                `;
            }
        }

        window.doLogin = loginWithGoogle;
        window.doLogout = logout;

        function loadWrong() {
            try { wrongIds = JSON.parse(localStorage.getItem(STORAGE_KEY)) || []; }
            catch(e) { wrongIds = []; }
        }

        function saveWrong() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(wrongIds));
            debouncedSync();
        }

        function loadStats() {
            try {
                const saved = JSON.parse(localStorage.getItem(STATS_KEY));
                if (saved) statsData = saved;
            } catch(e) {
                statsData = { materie: {}, argomenti: {} };
            }
        }

        function saveStats() {
            localStorage.setItem(STATS_KEY, JSON.stringify(statsData));
            debouncedSync();
        }

        function loadSimulations() {
            try {
                simulations = JSON.parse(localStorage.getItem(SIMULATIONS_KEY)) || [];
            } catch(e) {
                simulations = [];
            }
        }

        function saveSimulations() {
            localStorage.setItem(SIMULATIONS_KEY, JSON.stringify(simulations));
            debouncedSync();
        }

        function addSimulation(result) {
            simulations.unshift(result); // Add to beginning (most recent first)
            if (simulations.length > 50) simulations = simulations.slice(0, 50); // Keep max 50
            saveSimulations();
        }

        function loadProjectionHistory() {
            try {
                projectionHistory = JSON.parse(localStorage.getItem(PROJECTION_HISTORY_KEY)) || [];
            } catch(e) {
                projectionHistory = [];
            }
        }

        function saveProjectionHistory() {
            localStorage.setItem(PROJECTION_HISTORY_KEY, JSON.stringify(projectionHistory));
            debouncedSync();
        }

        // Calculate projected score based on performance per subject
        function calculateProjectedScore() {
            // Calculate overall average for subjects with no data (predictive approach)
            const totalAnswered = Object.values(statsData.materie).reduce((sum, m) => sum + m.total, 0);
            const totalCorrect = Object.values(statsData.materie).reduce((sum, m) => sum + m.correct, 0);
            const overallAvgPerQuestion = totalAnswered > 0 ? (totalCorrect / totalAnswered) : 0;

            let projectedScore = 0;
            let coveredSubjects = 0;
            let totalSubjects = Object.keys(SSM_DISTRIBUTION).length;

            Object.entries(SSM_DISTRIBUTION).forEach(([materia, questionCount]) => {
                const materiaStats = statsData.materie[materia];

                if (materiaStats && materiaStats.total > 0) {
                    // User has data for this subject
                    // Calculate average points per question: (correct - wrong*0.25) / total
                    // But we only track correct/total, so approximate with correct/total for now
                    // Actually, let's use: correct gives +1, wrong gives -0.25
                    // Since we track correct and total, wrong = total - correct
                    const correct = materiaStats.correct;
                    const wrong = materiaStats.total - correct;
                    const avgPointsPerQuestion = (correct * 1 + wrong * (-0.25)) / materiaStats.total;
                    projectedScore += avgPointsPerQuestion * questionCount;
                    coveredSubjects++;
                } else {
                    // No data for this subject - use overall average (predictive approach)
                    // Convert overall percentage to SSM points per question
                    const avgPointsPerQuestion = overallAvgPerQuestion * 1 + (1 - overallAvgPerQuestion) * (-0.25);
                    projectedScore += avgPointsPerQuestion * questionCount;
                }
            });

            return {
                score: Math.max(0, projectedScore), // Don't go below 0
                coveredSubjects,
                totalSubjects,
                coverage: totalSubjects > 0 ? Math.round(coveredSubjects / totalSubjects * 100) : 0
            };
        }

        // Add projected score to history after completing any session
        function recordProjectedScore() {
            const projection = calculateProjectedScore();
            projectionHistory.push({
                date: new Date().toISOString(),
                score: projection.score,
                coverage: projection.coverage
            });
            // Keep max 100 entries
            if (projectionHistory.length > 100) {
                projectionHistory = projectionHistory.slice(-100);
            }
            saveProjectionHistory();
        }

        // Get moving average of last N projected scores
        function getMovingAverageScore(n = 5) {
            if (projectionHistory.length === 0) return null;
            const recent = projectionHistory.slice(-n);
            const avg = recent.reduce((sum, p) => sum + p.score, 0) / recent.length;
            return avg;
        }

        function recordAnswer(materia, argomento, isCorrect) {
            // Materia stats
            if (!statsData.materie[materia]) {
                statsData.materie[materia] = { correct: 0, total: 0 };
            }
            statsData.materie[materia].total++;
            if (isCorrect) statsData.materie[materia].correct++;

            // Argomento stats
            const argKey = `${materia}|||${argomento}`;
            if (!statsData.argomenti[argKey]) {
                statsData.argomenti[argKey] = { correct: 0, total: 0, materia, argomento };
            }
            statsData.argomenti[argKey].total++;
            if (isCorrect) statsData.argomenti[argKey].correct++;

            saveStats();
        }

        function getWeakAreas(threshold = 60, minAnswers = 3) {
            const weak = [];

            // Check materie
            Object.entries(statsData.materie).forEach(([name, data]) => {
                if (data.total >= minAnswers) {
                    const pct = Math.round(data.correct / data.total * 100);
                    if (pct < threshold) {
                        weak.push({ type: 'materia', name, pct, total: data.total });
                    }
                }
            });

            // Check argomenti
            Object.entries(statsData.argomenti).forEach(([key, data]) => {
                if (data.total >= minAnswers) {
                    const pct = Math.round(data.correct / data.total * 100);
                    if (pct < threshold) {
                        weak.push({ type: 'argomento', name: data.argomento, materia: data.materia, pct, total: data.total });
                    }
                }
            });

            return weak.sort((a, b) => a.pct - b.pct);
        }

        function shuffle(arr) {
            const a = arr.slice();
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        function render(html) { app.innerHTML = html; }

        window.openModal = function(src) {
            const modal = document.getElementById('modal');
            const modalImg = document.getElementById('modal-img');
            if (modal && modalImg) {
                modalImg.src = src;
                modal.classList.add('visible');
            }
        };

        window.closeModal = function() {
            const modal = document.getElementById('modal');
            if (modal) modal.classList.remove('visible');
        };

        // ========== SHARED SESSION FUNCTIONS ==========

        function generateSessionCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function showCreateSharedSession() {
            selectedMaterie = [];
            render(`
                ${getAuthHeaderHtml()}
                <div class="start-screen">
                    <h1>Crea Sessione Condivisa</h1>
                    <p class="subtitle">Configura il quiz per il tuo gruppo</p>

                    <div style="max-width:400px;margin:0 auto;">
                        <div style="margin-bottom:20px;">
                            <label style="font-size:0.875rem;display:block;margin-bottom:8px;">Tipo di quiz</label>
                            <select id="quiz-type-select" style="width:100%;padding:12px;border:1px solid #e0e0e0;border-radius:6px;font-size:0.9375rem;">
                                <option value="140">Simulazione SSM (140 domande)</option>
                                <option value="20">Esercitazione rapida (20 domande)</option>
                                <option value="custom">Personalizzato</option>
                            </select>
                        </div>

                        <div id="custom-options" style="display:none;">
                            <div style="margin-bottom:20px;">
                                <label style="font-size:0.875rem;">Numero domande: <strong id="num-display">50</strong></label>
                                <input type="range" id="num-slider" min="10" max="100" value="50" style="width:100%;margin-top:8px;">
                            </div>
                            <div class="materie-filter" style="margin-bottom:20px;">
                                <h4 style="font-size:0.875rem;margin-bottom:8px;">Filtra per materie (opzionale)</h4>
                                <div class="filter-actions" style="margin-bottom:8px;">
                                    <button class="btn btn-secondary btn-small" id="select-all">Tutte</button>
                                    <button class="btn btn-secondary btn-small" id="select-none">Nessuna</button>
                                </div>
                                <div class="materie-grid" id="materie-grid">
                                    ${materie.map(m => `<span class="materia-chip" data-materia="${encodeURIComponent(m)}">${m}</span>`).join('')}
                                </div>
                            </div>
                        </div>

                        <div style="margin-bottom:20px;">
                            <label style="font-size:0.875rem;display:block;margin-bottom:8px;">Limite di tempo</label>
                            <select id="time-limit-select" style="width:100%;padding:12px;border:1px solid #e0e0e0;border-radius:6px;font-size:0.9375rem;">
                                <option value="0">Nessun limite</option>
                                <option value="30">30 minuti</option>
                                <option value="60">1 ora</option>
                                <option value="90">1 ora e 30 minuti</option>
                                <option value="120">2 ore</option>
                                <option value="210" selected>3 ore e 30 minuti (SSM)</option>
                            </select>
                        </div>
                    </div>

                    <div class="actions" style="justify-content:center;margin-top:24px;">
                        <button class="btn btn-secondary" id="back-btn">Indietro</button>
                        <button class="btn btn-primary" id="create-session-btn">Crea sessione</button>
                    </div>
                </div>
            `);

            const quizTypeSelect = document.getElementById('quiz-type-select');
            const customOptions = document.getElementById('custom-options');
            const timeLimitSelect = document.getElementById('time-limit-select');
            const slider = document.getElementById('num-slider');
            const numDisplay = document.getElementById('num-display');

            quizTypeSelect.addEventListener('change', () => {
                const isCustom = quizTypeSelect.value === 'custom';
                customOptions.style.display = isCustom ? 'block' : 'none';
                // Set default time limit based on quiz type
                if (quizTypeSelect.value === '140') {
                    timeLimitSelect.value = '210';
                } else if (quizTypeSelect.value === '20') {
                    timeLimitSelect.value = '30';
                } else {
                    timeLimitSelect.value = '60';
                }
            });

            if (slider) {
                slider.addEventListener('input', () => numDisplay.textContent = slider.value);
            }

            document.querySelectorAll('.materia-chip').forEach(chip => {
                chip.addEventListener('click', function() {
                    this.classList.toggle('selected');
                    const m = decodeURIComponent(this.dataset.materia);
                    if (this.classList.contains('selected')) {
                        selectedMaterie.push(m);
                    } else {
                        selectedMaterie = selectedMaterie.filter(x => x !== m);
                    }
                });
            });

            document.getElementById('select-all')?.addEventListener('click', () => {
                selectedMaterie = [...materie];
                document.querySelectorAll('.materia-chip').forEach(c => c.classList.add('selected'));
            });

            document.getElementById('select-none')?.addEventListener('click', () => {
                selectedMaterie = [];
                document.querySelectorAll('.materia-chip').forEach(c => c.classList.remove('selected'));
            });

            document.getElementById('back-btn').addEventListener('click', showStart);
            document.getElementById('create-session-btn').addEventListener('click', async () => {
                const quizType = quizTypeSelect.value;
                const timeLimit = parseInt(timeLimitSelect.value) || null;
                let questionCount = quizType === '140' ? 140 : quizType === '20' ? 20 : parseInt(slider.value);
                await createSharedSession(quizType, questionCount, timeLimit);
            });
        }

        async function createSharedSession(quizType, questionCount, timeLimit) {
            if (!currentUser) return;

            // Generate unique code
            let code = generateSessionCode();
            let attempts = 0;

            // Select questions based on quiz type
            let questionIds;
            if (quizType === '140') {
                questionIds = selectSSMQuestions();
            } else if (quizType === 'custom' && selectedMaterie.length > 0) {
                let filtered = questions.map((q, i) => i).filter(i => selectedMaterie.includes(questions[i].materia));
                questionIds = shuffle(filtered).slice(0, Math.min(questionCount, filtered.length));
            } else {
                questionIds = shuffle(questions.map((q, i) => i)).slice(0, questionCount);
            }

            if (questionIds.length === 0) {
                alert('Nessuna domanda disponibile per i criteri selezionati');
                return;
            }

            try {
                // Create session
                const { data: session, error } = await supabase
                    .from('shared_sessions')
                    .insert({
                        code: code,
                        created_by: currentUser.id,
                        creator_name: currentUser.email.split('@')[0],
                        question_ids: questionIds,
                        quiz_type: quizType,
                        question_count: questionIds.length,
                        time_limit: timeLimit,
                        status: 'waiting'
                    })
                    .select()
                    .single();

                if (error) throw error;

                // Add creator as participant
                const { error: participantError } = await supabase
                    .from('session_participants')
                    .insert({
                        session_id: session.id,
                        user_id: currentUser.id,
                        user_name: currentUser.email.split('@')[0],
                        user_email: currentUser.email
                    });

                if (participantError) throw participantError;

                sharedSession = session;
                showLobby(true); // true = is host

            } catch (err) {
                console.error('Error creating session:', err);
                alert('Errore nella creazione della sessione: ' + err.message);
            }
        }

        function showJoinSession() {
            render(`
                ${getAuthHeaderHtml()}
                <div class="start-screen">
                    <h1>Unisciti a una Sessione</h1>
                    <p class="subtitle">Inserisci il codice della sessione condiviso dall'host</p>

                    <div style="margin:32px 0;">
                        <input type="text" id="session-code-input" class="join-input" maxlength="6" placeholder="CODICE" autocomplete="off">
                    </div>

                    <div class="actions" style="justify-content:center;">
                        <button class="btn btn-secondary" id="back-btn">Indietro</button>
                        <button class="btn btn-primary" id="join-btn">Unisciti</button>
                    </div>

                    <p id="join-error" style="color:#cb2431;margin-top:16px;display:none;"></p>
                </div>
            `);

            const input = document.getElementById('session-code-input');
            input.addEventListener('input', (e) => {
                e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
            });

            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('join-btn').click();
            });

            document.getElementById('back-btn').addEventListener('click', showStart);
            document.getElementById('join-btn').addEventListener('click', async () => {
                const code = input.value.trim();
                if (code.length !== 6) {
                    document.getElementById('join-error').textContent = 'Il codice deve essere di 6 caratteri';
                    document.getElementById('join-error').style.display = 'block';
                    return;
                }
                await joinSharedSession(code);
            });

            input.focus();
        }

        async function joinSharedSession(code) {
            if (!currentUser) return;

            const errorEl = document.getElementById('join-error');

            try {
                // Find session by code
                const { data: session, error } = await supabase
                    .from('shared_sessions')
                    .select('*')
                    .eq('code', code.toUpperCase())
                    .single();

                if (error || !session) {
                    errorEl.textContent = 'Sessione non trovata. Verifica il codice.';
                    errorEl.style.display = 'block';
                    return;
                }

                if (session.status !== 'waiting') {
                    errorEl.textContent = 'Questa sessione Ã¨ giÃ  iniziata o terminata.';
                    errorEl.style.display = 'block';
                    return;
                }

                // Check if already joined
                const { data: existingParticipant } = await supabase
                    .from('session_participants')
                    .select('*')
                    .eq('session_id', session.id)
                    .eq('user_id', currentUser.id)
                    .single();

                if (!existingParticipant) {
                    // Add user as participant
                    const { error: participantError } = await supabase
                        .from('session_participants')
                        .insert({
                            session_id: session.id,
                            user_id: currentUser.id,
                            user_name: currentUser.email.split('@')[0],
                            user_email: currentUser.email
                        });

                    if (participantError) throw participantError;
                }

                sharedSession = session;
                showLobby(session.created_by === currentUser.id);

            } catch (err) {
                console.error('Error joining session:', err);
                errorEl.textContent = 'Errore: ' + err.message;
                errorEl.style.display = 'block';
            }
        }

        async function showLobby(isHost) {
            if (!sharedSession) {
                showStart();
                return;
            }

            // Clear any existing poll
            if (lobbyPollInterval) {
                clearInterval(lobbyPollInterval);
                lobbyPollInterval = null;
            }

            // Subscribe to realtime updates
            subscribeToSession(sharedSession.id);

            // Fetch current participants
            await refreshParticipants();

            renderLobby(isHost);

            // Start polling as fallback (every 3 seconds)
            lobbyPollInterval = setInterval(async () => {
                if (!sharedSession || sharedSession.status !== 'waiting') {
                    clearInterval(lobbyPollInterval);
                    lobbyPollInterval = null;
                    return;
                }

                // Check for session status changes
                const { data: sessionData } = await supabase
                    .from('shared_sessions')
                    .select('status, started_at')
                    .eq('id', sharedSession.id)
                    .single();

                if (sessionData && sessionData.status === 'active' && sharedSession.status === 'waiting') {
                    sharedSession.status = 'active';
                    sharedSession.started_at = sessionData.started_at;
                    clearInterval(lobbyPollInterval);
                    lobbyPollInterval = null;
                    startSharedQuiz();
                    return;
                }

                // Refresh participants
                const prevCount = sessionParticipants.length;
                await refreshParticipants();
                if (sessionParticipants.length !== prevCount) {
                    renderLobby(sharedSession.created_by === currentUser.id);
                }
            }, 3000);
        }

        async function refreshParticipants() {
            const { data, error } = await supabase
                .from('session_participants')
                .select('*')
                .eq('session_id', sharedSession.id)
                .order('joined_at', { ascending: true });

            if (!error && data) {
                sessionParticipants = data;
            }
        }

        function renderLobby(isHost) {
            const quizTypeLabels = {
                '140': 'Simulazione SSM',
                '20': 'Esercitazione rapida',
                'custom': 'Quiz personalizzato'
            };

            render(`
                ${getAuthHeaderHtml()}
                <div class="lobby-screen">
                    <h1>Sessione Condivisa</h1>
                    <p class="subtitle">${isHost ? 'Condividi il codice con i partecipanti' : 'In attesa che l\'host avvii la sessione'}</p>

                    <div class="session-code-label">Codice sessione</div>
                    <div class="session-code">${sharedSession.code}</div>

                    <div class="session-info">
                        <div class="session-info-row">
                            <span class="session-info-label">Tipo quiz</span>
                            <span class="session-info-value">${quizTypeLabels[sharedSession.quiz_type] || sharedSession.quiz_type}</span>
                        </div>
                        <div class="session-info-row">
                            <span class="session-info-label">Domande</span>
                            <span class="session-info-value">${sharedSession.question_count}</span>
                        </div>
                        <div class="session-info-row">
                            <span class="session-info-label">Tempo</span>
                            <span class="session-info-value">${sharedSession.time_limit ? sharedSession.time_limit + ' minuti' : 'Illimitato'}</span>
                        </div>
                    </div>

                    <div class="participant-list">
                        <h3>Partecipanti (${sessionParticipants.length})</h3>
                        ${sessionParticipants.map(p => `
                            <div class="participant-item">
                                <div class="participant-avatar">${(p.user_name || p.user_email || '?')[0].toUpperCase()}</div>
                                <div class="participant-name">${p.user_name || p.user_email}</div>
                                ${p.user_id === sharedSession.created_by ? '<span class="participant-host">Host</span>' : ''}
                                <span class="participant-status">Pronto</span>
                            </div>
                        `).join('')}
                    </div>

                    ${!isHost ? `
                        <div class="waiting-animation">
                            <div class="waiting-dot"></div>
                            <div class="waiting-dot"></div>
                            <div class="waiting-dot"></div>
                        </div>
                        <p style="color:#666;font-size:0.875rem;">In attesa dell'host...</p>
                    ` : ''}

                    <div class="actions" style="justify-content:center;margin-top:24px;">
                        <button class="btn btn-secondary" id="leave-btn">Abbandona</button>
                        ${isHost ? '<button class="btn btn-primary" id="start-session-btn">Avvia sessione</button>' : ''}
                    </div>
                </div>
            `);

            document.getElementById('leave-btn').addEventListener('click', async () => {
                if (confirm('Sei sicuro di voler abbandonare la sessione?')) {
                    await leaveSession();
                }
            });

            if (isHost) {
                document.getElementById('start-session-btn').addEventListener('click', async () => {
                    if (sessionParticipants.length < 1) {
                        alert('Attendi almeno un partecipante');
                        return;
                    }
                    await startSharedSession();
                });
            }
        }

        function subscribeToSession(sessionId) {
            // Clean up existing subscription
            if (sessionChannel) {
                supabase.removeChannel(sessionChannel);
                sessionChannel = null;
            }

            console.log('Subscribing to session:', sessionId);

            sessionChannel = supabase.channel(`session-${sessionId}`)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'session_participants', filter: `session_id=eq.${sessionId}` },
                    async (payload) => {
                        console.log('Participant change received:', payload);
                        await refreshParticipants();
                        // Re-render lobby if still in lobby
                        if (sharedSession && sharedSession.status === 'waiting') {
                            renderLobby(sharedSession.created_by === currentUser.id);
                        } else if (sharedSession && sharedSession.status === 'active') {
                            // Update leaderboard if in results
                            const resultsEl = document.querySelector('.leaderboard');
                            if (resultsEl) {
                                updateSharedLeaderboard();
                            }
                        }
                    })
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'shared_sessions', filter: `id=eq.${sessionId}` },
                    (payload) => {
                        console.log('Session change received:', payload);
                        const newStatus = payload.new.status;
                        if (newStatus === 'active' && sharedSession.status === 'waiting') {
                            sharedSession = payload.new;
                            startSharedQuiz();
                        } else if (newStatus === 'completed') {
                            sharedSession = payload.new;
                        } else {
                            sharedSession = payload.new;
                        }
                    })
                .subscribe((status, err) => {
                    console.log('Realtime subscription status:', status, err);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to realtime updates');
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error('Realtime channel error:', err);
                    }
                });
        }

        async function leaveSession() {
            // Stop polling
            if (lobbyPollInterval) {
                clearInterval(lobbyPollInterval);
                lobbyPollInterval = null;
            }

            if (sharedSession && currentUser) {
                const isHost = sharedSession.created_by === currentUser.id;
                const sessionId = sharedSession.id;

                if (isHost) {
                    // Host leaving: delete the entire session (CASCADE deletes participants)
                    await supabase
                        .from('shared_sessions')
                        .delete()
                        .eq('id', sessionId);
                } else {
                    // Participant leaving: just remove themselves
                    await supabase
                        .from('session_participants')
                        .delete()
                        .eq('session_id', sessionId)
                        .eq('user_id', currentUser.id);
                }
            }

            if (sessionChannel) {
                supabase.removeChannel(sessionChannel);
                sessionChannel = null;
            }

            sharedSession = null;
            sessionParticipants = [];
            showStart();
        }

        async function startSharedSession() {
            if (!sharedSession || sharedSession.created_by !== currentUser.id) return;

            try {
                const { error } = await supabase
                    .from('shared_sessions')
                    .update({
                        status: 'active',
                        started_at: new Date().toISOString()
                    })
                    .eq('id', sharedSession.id);

                if (error) throw error;

                // The realtime subscription will trigger startSharedQuiz for everyone
            } catch (err) {
                console.error('Error starting session:', err);
                alert('Errore nell\'avvio della sessione: ' + err.message);
            }
        }

        function startSharedQuiz() {
            if (!sharedSession) return;

            // Stop lobby polling
            if (lobbyPollInterval) {
                clearInterval(lobbyPollInterval);
                lobbyPollInterval = null;
            }

            // Clear any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            const pool = sharedSession.question_ids;
            const startTime = new Date(sharedSession.started_at).getTime();
            const endTime = sharedSession.time_limit
                ? startTime + (sharedSession.time_limit * 60 * 1000)
                : null;

            quiz = {
                pool,
                current: 0,
                correct: 0,
                wrong: 0,
                skipped: 0,
                mistakes: [],
                mode: 'shared',
                startTime,
                endTime,
                answers: {},
                questionOptions: {},
                isShared: true
            };

            showQuestion();
        }

        async function finishSharedQuiz() {
            clearInterval(timerInterval);
            timerInterval = null;

            if (!sharedSession || !quiz) return;

            // Calculate subject breakdown
            const subjectBreakdown = {};

            // Calculate results
            quiz.pool.forEach((qIdx) => {
                const q = questions[qIdx];
                const answer = quiz.answers[qIdx];

                if (!subjectBreakdown[q.materia]) {
                    subjectBreakdown[q.materia] = { correct: 0, wrong: 0, skipped: 0 };
                }

                if (answer === undefined) {
                    quiz.skipped++;
                    subjectBreakdown[q.materia].skipped++;
                } else {
                    const selectedOption = q.risposte.find(r => r.id === answer);
                    if (selectedOption && selectedOption.isCorrect) {
                        quiz.correct++;
                        subjectBreakdown[q.materia].correct++;
                    } else {
                        quiz.wrong++;
                        subjectBreakdown[q.materia].wrong++;
                        quiz.mistakes.push({
                            domanda: q.domanda,
                            materia: q.materia,
                            argomento: q.argomenti,
                            tua: selectedOption ? selectedOption.text : 'N/A',
                            corretta: q.risposta_corretta_text,
                            commento: q.commento,
                            has_image: q.has_image,
                            image_src: q.image_src
                        });
                        if (!wrongIds.includes(qIdx)) { wrongIds.push(qIdx); saveWrong(); }
                    }

                    const isCorrect = selectedOption && selectedOption.isCorrect;
                    recordAnswer(q.materia, q.argomenti, isCorrect);
                }
            });

            const ssmScore = quiz.correct * 1 + quiz.wrong * (-0.25);

            // Save results to session_participants
            try {
                await supabase
                    .from('session_participants')
                    .update({
                        answers: quiz.answers,
                        score: ssmScore,
                        correct: quiz.correct,
                        wrong: quiz.wrong,
                        skipped: quiz.skipped,
                        completed_at: new Date().toISOString()
                    })
                    .eq('session_id', sharedSession.id)
                    .eq('user_id', currentUser.id);
            } catch (err) {
                console.error('Error saving results:', err);
            }

            recordProjectedScore();
            showSharedResults();
        }

        async function showSharedResults() {
            await refreshParticipants();

            const total = quiz.pool.length;
            const ssmScore = quiz.correct * 1 + quiz.wrong * (-0.25);
            const maxScore = total;

            // Sort participants by score (completed first, then by score)
            // Helper to check if participant data is fully synced
            const isParticipantComplete = (p) => p.completed_at && p.score != null;

            const sortedParticipants = [...sessionParticipants].sort((a, b) => {
                const aComplete = isParticipantComplete(a);
                const bComplete = isParticipantComplete(b);
                if (aComplete && !bComplete) return -1;
                if (!aComplete && bComplete) return 1;
                return (b.score ?? 0) - (a.score ?? 0);
            });

            const completedCount = sessionParticipants.filter(isParticipantComplete).length;

            render(`
                ${getAuthHeaderHtml()}
                <div class="results">
                    <h2>Risultati Sessione Condivisa</h2>
                    <div class="score">${ssmScore.toFixed(2)}</div>
                    <div class="score-label">Il tuo punteggio su ${maxScore}</div>

                    <div class="results-breakdown">
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#22863a;">+${quiz.correct}</div><div class="breakdown-label">Corrette (+1)</div></div>
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#cb2431;">${quiz.wrong > 0 ? '-' + (quiz.wrong * 0.25).toFixed(2) : '0'}</div><div class="breakdown-label">Errate (-0.25)</div></div>
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#888;">${quiz.skipped}</div><div class="breakdown-label">Omesse (0)</div></div>
                    </div>

                    <div class="leaderboard" id="leaderboard">
                        <h3>Classifica (${completedCount}/${sessionParticipants.length} completati)</h3>
                        ${sortedParticipants.map((p, idx) => {
                            const pComplete = isParticipantComplete(p);
                            const scoreClass = pComplete ? (p.score >= 100 ? 'good' : p.score >= 70 ? 'medium' : 'bad') : '';
                            const isMe = p.user_id === currentUser.id;
                            return `
                                <div class="leaderboard-item" ${isMe ? 'style="border:2px solid #0969da;"' : ''}>
                                    <div class="leaderboard-rank">${pComplete ? idx + 1 : '-'}</div>
                                    <div class="leaderboard-user">
                                        <div class="leaderboard-user-name">${p.user_name || p.user_email}${isMe ? ' (tu)' : ''}</div>
                                        <div class="leaderboard-user-stats">
                                            ${pComplete
                                                ? `â${p.correct ?? 0} â${p.wrong ?? 0} â${p.skipped ?? 0}`
                                                : '<span style="color:#dbab09;">In corso...</span>'}
                                        </div>
                                    </div>
                                    <div class="leaderboard-score ${scoreClass}">${pComplete ? p.score.toFixed(2) : '...'}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>

                    <div class="actions" style="justify-content:center;">
                        <button class="btn btn-primary" id="home-btn">Torna al menu</button>
                    </div>

                    ${quiz.mistakes.length > 0 ? `
                        <div class="review-section">
                            <h3>Da ripassare (${quiz.mistakes.length})</h3>
                            ${quiz.mistakes.map(m => `
                                <div class="review-item">
                                    <div class="review-materia">${m.materia} â ${m.argomento}</div>
                                    <div class="review-question">${m.domanda}</div>
                                    ${m.has_image && m.image_src ? `<div class="review-image"><img src="${m.image_src}" alt="Immagine"></div>` : ''}
                                    <div class="review-your">Hai risposto: ${m.tua}</div>
                                    <div class="review-correct">Corretta: ${m.corretta}</div>
                                    ${m.commento ? `<div class="review-commento">${m.commento}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `);

            document.getElementById('home-btn').addEventListener('click', async () => {
                if (sessionChannel) {
                    supabase.removeChannel(sessionChannel);
                    sessionChannel = null;
                }
                sharedSession = null;
                sessionParticipants = [];
                showStart();
            });
        }

        async function updateSharedLeaderboard() {
            const leaderboardEl = document.getElementById('leaderboard');
            if (!leaderboardEl) return;

            await refreshParticipants();

            // Helper to check if participant data is fully synced
            const isParticipantComplete = (p) => p.completed_at && p.score != null;

            const sortedParticipants = [...sessionParticipants].sort((a, b) => {
                const aComplete = isParticipantComplete(a);
                const bComplete = isParticipantComplete(b);
                if (aComplete && !bComplete) return -1;
                if (!aComplete && bComplete) return 1;
                return (b.score ?? 0) - (a.score ?? 0);
            });

            const completedCount = sessionParticipants.filter(isParticipantComplete).length;

            leaderboardEl.innerHTML = `
                <h3>Classifica (${completedCount}/${sessionParticipants.length} completati)</h3>
                ${sortedParticipants.map((p, idx) => {
                    const pComplete = isParticipantComplete(p);
                    const scoreClass = pComplete ? (p.score >= 100 ? 'good' : p.score >= 70 ? 'medium' : 'bad') : '';
                    const isMe = p.user_id === currentUser.id;
                    return `
                        <div class="leaderboard-item" ${isMe ? 'style="border:2px solid #0969da;"' : ''}>
                            <div class="leaderboard-rank">${pComplete ? idx + 1 : '-'}</div>
                            <div class="leaderboard-user">
                                <div class="leaderboard-user-name">${p.user_name || p.user_email}${isMe ? ' (tu)' : ''}</div>
                                <div class="leaderboard-user-stats">
                                    ${pComplete
                                        ? `â${p.correct ?? 0} â${p.wrong ?? 0} â${p.skipped ?? 0}`
                                        : '<span style="color:#dbab09;">In corso...</span>'}
                                </div>
                            </div>
                            <div class="leaderboard-score ${scoreClass}">${pComplete ? p.score.toFixed(2) : '...'}</div>
                        </div>
                    `;
                }).join('')}
            `;
        }

        // ========== END SHARED SESSION FUNCTIONS ==========

        function showStart() {
            // Check authorization
            if (!currentUser) {
                showLoginRequired();
                return;
            }
            if (!isAuthorized) {
                showUnauthorized();
                return;
            }

            // Clear any running timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            loadWrong();
            loadStats();
            loadSimulations();
            loadProjectionHistory();
            const wrongDisabled = wrongIds.length === 0 ? 'disabled' : '';
            const weakAreas = getWeakAreas();
            const hasStats = Object.keys(statsData.materie).length > 0 || simulations.length > 0;

            render(`
                ${getAuthHeaderHtml()}
                <div class="start-screen">
                    <h1>Simulatore SSM</h1>
                    <p class="subtitle">Quiz di preparazione alle Specializzazioni Mediche</p>
                    <div class="mode-select">
                        <div class="mode-section">
                            <div class="mode-section-title">Studio individuale</div>
                            <div class="mode-option selected" data-mode="140">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><line x1="12" y1="6" x2="12" y2="10"/><line x1="12" y1="14" x2="12" y2="14"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Simulazione SSM</strong>
                                    <span>140 domande Â· 3h 30min</span>
                                </div>
                                ${simulations.length > 0 ? `<span class="mode-option-badge" style="background:#e8f4fd;color:#0969da;">${simulations.length} fatte</span>` : ''}
                            </div>
                            <div class="mode-option" data-mode="20">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Esercitazione rapida</strong>
                                    <span>20 domande casuali</span>
                                </div>
                            </div>
                            <div class="mode-option" data-mode="custom">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Personalizzato</strong>
                                    <span>Scegli materie e numero</span>
                                </div>
                            </div>
                        </div>

                        ${(wrongIds.length > 0 || weakAreas.length > 0) ? `
                        <div class="mode-section">
                            <div class="mode-section-title">Ripasso mirato</div>
                            ${wrongIds.length > 0 ? `
                            <div class="mode-option" data-mode="wrong">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Ripassa errori</strong>
                                    <span>Rivedi le domande sbagliate</span>
                                </div>
                                <span class="mode-option-badge" style="background:#fff3cd;color:#856404;">${wrongIds.length}</span>
                            </div>
                            ` : ''}
                            ${weakAreas.length > 0 ? `
                            <div class="mode-option" data-mode="weak">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Rinforza punti deboli</strong>
                                    <span>Aree con percentuale bassa</span>
                                </div>
                                <span class="mode-option-badge" style="background:#ffeef0;color:#cb2431;">${weakAreas.length}</span>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}

                        <div class="mode-section">
                            <div class="mode-section-title">Multiplayer</div>
                            <div class="mode-option" data-mode="shared-create">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Crea sessione condivisa</strong>
                                    <span>Invita altri a fare lo stesso test</span>
                                </div>
                            </div>
                            <div class="mode-option" data-mode="shared-join">
                                <div class="mode-option-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg>
                                </div>
                                <div class="mode-option-content">
                                    <strong>Unisciti a sessione</strong>
                                    <span>Inserisci il codice di invito</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
                        <button class="btn btn-primary" id="start-btn">Inizia</button>
                        ${hasStats ? `<button class="btn btn-secondary" id="stats-btn">ð Statistiche</button>` : ''}
                    </div>
                    <p style="margin-top:24px;font-size:0.8rem;color:#888;">${questions.length} domande disponibili</p>
                </div>
            `);

            let selectedMode = '140';
            document.querySelectorAll('.mode-option').forEach(el => {
                el.addEventListener('click', function() {
                    if (this.classList.contains('disabled')) return;
                    document.querySelectorAll('.mode-option').forEach(e => e.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedMode = this.dataset.mode;
                });
            });

            document.getElementById('start-btn').addEventListener('click', () => {
                if (selectedMode === 'custom') {
                    showCustomSetup();
                } else if (selectedMode === 'weak') {
                    startWeakAreasQuiz();
                } else if (selectedMode === 'shared-create') {
                    showCreateSharedSession();
                } else if (selectedMode === 'shared-join') {
                    showJoinSession();
                } else {
                    startQuiz(selectedMode);
                }
            });

            const statsBtn = document.getElementById('stats-btn');
            if (statsBtn) {
                statsBtn.addEventListener('click', showStats);
            }
        }

        function showStats() {
            loadStats();
            loadSimulations();
            loadProjectionHistory();

            const totalAnswered = Object.values(statsData.materie).reduce((sum, m) => sum + m.total, 0);
            const totalCorrect = Object.values(statsData.materie).reduce((sum, m) => sum + m.correct, 0);
            const overallPct = totalAnswered > 0 ? Math.round(totalCorrect / totalAnswered * 100) : 0;
            const weakAreas = getWeakAreas();

            // Projected score calculations
            const projection = calculateProjectedScore();
            const movingAvg = getMovingAverageScore(5);
            const currentProjected = movingAvg !== null ? movingAvg : projection.score;

            // Calculate trend (compare last 5 with previous 5)
            let trend = null;
            if (projectionHistory.length >= 10) {
                const recent5 = projectionHistory.slice(-5).reduce((s, p) => s + p.score, 0) / 5;
                const prev5 = projectionHistory.slice(-10, -5).reduce((s, p) => s + p.score, 0) / 5;
                trend = recent5 - prev5;
            } else if (projectionHistory.length >= 2) {
                trend = projectionHistory[projectionHistory.length - 1].score - projectionHistory[0].score;
            }

            // Simulation stats
            const avgSimScore = simulations.length > 0
                ? (simulations.reduce((sum, s) => sum + s.score, 0) / simulations.length).toFixed(1)
                : 0;

            // Sort materie by percentage (ascending = worst first)
            const materieStats = Object.entries(statsData.materie)
                .map(([name, data]) => ({
                    name,
                    correct: data.correct,
                    total: data.total,
                    pct: Math.round(data.correct / data.total * 100)
                }))
                .sort((a, b) => a.pct - b.pct);

            // Group argomenti by materia
            const argomentiByMateria = {};
            Object.entries(statsData.argomenti).forEach(([key, data]) => {
                if (!argomentiByMateria[data.materia]) {
                    argomentiByMateria[data.materia] = [];
                }
                argomentiByMateria[data.materia].push({
                    name: data.argomento,
                    correct: data.correct,
                    total: data.total,
                    pct: Math.round(data.correct / data.total * 100)
                });
            });

            Object.keys(argomentiByMateria).forEach(m => {
                argomentiByMateria[m].sort((a, b) => a.pct - b.pct);
            });

            function getBarClass(pct) {
                if (pct >= 70) return 'good';
                if (pct >= 50) return 'medium';
                return 'bad';
            }

            // KPI trend class
            const trendClass = trend !== null ? (trend >= 0 ? 'trend-up' : 'trend-down') : '';
            const trendIcon = trend !== null ? (trend >= 0 ? 'â' : 'â') : '';
            const trendText = trend !== null ? `${trendIcon} ${Math.abs(trend).toFixed(1)}` : '-';

            render(`
                ${getAuthHeaderHtml()}
                <div class="stats-screen">
                    <!-- Main KPI: Projected Score -->
                    <div class="kpi-main">
                        <div class="kpi-label">Punteggio Proiettato SSM</div>
                        <div class="kpi-value">${currentProjected.toFixed(1)}<span class="kpi-max"> / 140</span></div>
                        <div class="kpi-subtitle">Media mobile ultimi 5 quiz Â· Copertura ${projection.coverage}% materie (${projection.coveredSubjects}/${projection.totalSubjects})</div>
                    </div>

                    <!-- Secondary KPIs -->
                    <div class="kpi-secondary">
                        <div class="kpi-card ${trendClass}">
                            <div class="value">${trendText}</div>
                            <div class="label">Trend</div>
                        </div>
                        <div class="kpi-card">
                            <div class="value">${projectionHistory.length}</div>
                            <div class="label">Sessioni</div>
                        </div>
                        <div class="kpi-card">
                            <div class="value">${totalAnswered}</div>
                            <div class="label">Risposte totali</div>
                        </div>
                    </div>

                    <!-- Chart -->
                    <div class="chart-container">
                        <h3>Andamento nel tempo</h3>
                        ${projectionHistory.length >= 2 ? `
                            <div class="chart-wrapper">
                                <canvas id="progression-chart"></canvas>
                            </div>
                        ` : `
                            <div class="no-chart-data">Completa almeno 2 sessioni di studio per vedere il grafico di andamento</div>
                        `}
                    </div>

                    <!-- Tabs -->
                    <div class="stats-tabs">
                        <button class="stats-tab active" data-tab="materie">Materie</button>
                        <button class="stats-tab" data-tab="simulazioni">Simulazioni (${simulations.length})</button>
                    </div>

                    <!-- Tab: Materie -->
                    <div class="stats-tab-content active" id="tab-materie">
                        ${weakAreas.length > 0 ? `
                            <div class="weak-areas">
                                <h3>Aree da ripassare (sotto 60%)</h3>
                                <ul>
                                    ${weakAreas.slice(0, 8).map(w => `
                                        <li>
                                            <span>${w.type === 'argomento' ? `${w.materia} â ${w.name}` : w.name}</span>
                                            <span class="weak-pct">${w.pct}% (${w.total})</span>
                                        </li>
                                    `).join('')}
                                </ul>
                                <button class="btn btn-primary btn-small practice-weak-btn" id="practice-weak-btn">Esercitati su questi argomenti</button>
                            </div>
                        ` : ''}

                        ${materieStats.length > 0 ? `
                            <div class="stats-section">
                                <h3>Performance per Materia</h3>
                                ${materieStats.map(m => `
                                    <div class="stat-row materia-row" data-materia="${encodeURIComponent(m.name)}">
                                        <div class="stat-name"><span title="${m.name}">${m.name}</span></div>
                                        <div class="stat-bar-container">
                                            <div class="stat-bar ${getBarClass(m.pct)}" style="width:${m.pct}%"></div>
                                        </div>
                                        <div class="stat-value">${m.pct}%</div>
                                        <div class="stat-count">${m.total}</div>
                                    </div>
                                    <div class="argomenti-list" id="arg-${encodeURIComponent(m.name)}">
                                        ${(argomentiByMateria[m.name] || []).map(a => `
                                            <div class="stat-row">
                                                <div class="stat-name"><span title="${a.name}">${a.name}</span></div>
                                                <div class="stat-bar-container">
                                                    <div class="stat-bar ${getBarClass(a.pct)}" style="width:${a.pct}%"></div>
                                                </div>
                                                <div class="stat-value">${a.pct}%</div>
                                                <div class="stat-count">${a.total}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                `).join('')}
                                <p style="margin-top:12px;font-size:0.75rem;color:#888;">Clicca su una materia per vedere gli argomenti</p>
                            </div>
                        ` : '<div class="no-stats">Nessuna statistica per materia ancora.</div>'}
                    </div>

                    <!-- Tab: Simulazioni -->
                    <div class="stats-tab-content" id="tab-simulazioni">
                        ${simulations.length > 0 ? `
                            <div style="margin-bottom:16px;padding:12px;background:#f5f5f5;border-radius:6px;display:flex;justify-content:space-around;text-align:center;">
                                <div><div style="font-size:1.25rem;font-weight:600;">${simulations.length}</div><div style="font-size:0.75rem;color:#666;">Simulazioni</div></div>
                                <div><div style="font-size:1.25rem;font-weight:600;">${avgSimScore}</div><div style="font-size:0.75rem;color:#666;">Media punti</div></div>
                                <div><div style="font-size:1.25rem;font-weight:600;">${simulations.length > 0 ? Math.max(...simulations.map(s => s.score)).toFixed(1) : 0}</div><div style="font-size:0.75rem;color:#666;">Miglior punteggio</div></div>
                            </div>
                            <div class="simulation-cards">
                                ${simulations.map((sim, idx) => {
                                    const scoreClass = sim.score >= 100 ? 'good' : sim.score >= 70 ? 'medium' : 'bad';
                                    const dateStr = new Date(sim.date).toLocaleDateString('it-IT', {
                                        day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit'
                                    });
                                    return `
                                        <div class="simulation-card" data-sim-index="${idx}">
                                            <div class="simulation-header">
                                                <span class="simulation-date">${dateStr}</span>
                                                <span class="simulation-score ${scoreClass}">${sim.score.toFixed(2)} / ${sim.total}</span>
                                            </div>
                                            <div class="simulation-stats">
                                                <span>â ${sim.correct}</span>
                                                <span>â ${sim.wrong}</span>
                                                <span>â ${sim.skipped}</span>
                                                <span>â± ${sim.duration}min</span>
                                            </div>
                                            <div class="simulation-details">
                                                <div style="font-size:0.8125rem;font-weight:500;margin-bottom:8px;">Dettaglio per materia:</div>
                                                <div class="simulation-breakdown">
                                                    ${sim.subjectBreakdown ? Object.entries(sim.subjectBreakdown)
                                                        .sort((a, b) => (b[1].correct - b[1].wrong * 0.25) - (a[1].correct - a[1].wrong * 0.25))
                                                        .map(([materia, data]) => {
                                                            const matScore = data.correct - data.wrong * 0.25;
                                                            const matTotal = data.correct + data.wrong + data.skipped;
                                                            return `<div class="breakdown-row">
                                                                <span class="materia-name">${materia}</span>
                                                                <span class="materia-score">${matScore.toFixed(1)}/${matTotal}</span>
                                                            </div>`;
                                                        }).join('') : '<div style="color:#888;font-size:0.8125rem;">Dettaglio non disponibile</div>'}
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : '<div class="no-simulations">Nessuna simulazione completata. Prova una Simulazione SSM!</div>'}
                    </div>

                    <div class="actions" style="justify-content:center;margin-top:24px;">
                        <button class="btn btn-secondary" id="back-btn">Torna al menu</button>
                        ${totalAnswered > 0 || simulations.length > 0 || projectionHistory.length > 0 ? '<button class="btn btn-danger btn-small" id="reset-stats-btn">Azzera tutto</button>' : ''}
                    </div>
                </div>
            `);

            // Initialize chart if data available
            if (projectionHistory.length >= 2) {
                const ctx = document.getElementById('progression-chart');
                if (ctx && window.Chart) {
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: projectionHistory.map(p => {
                                const d = new Date(p.date);
                                return d.toLocaleDateString('it-IT', { day: 'numeric', month: 'short' });
                            }),
                            datasets: [{
                                label: 'Punteggio Proiettato',
                                data: projectionHistory.map(p => p.score.toFixed(1)),
                                borderColor: '#1a1a1a',
                                backgroundColor: 'rgba(26, 26, 26, 0.1)',
                                tension: 0.3,
                                fill: true,
                                pointRadius: 4,
                                pointHoverRadius: 6
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    min: 0,
                                    max: 140,
                                    ticks: { stepSize: 20 }
                                },
                                x: {
                                    ticks: { maxRotation: 45, minRotation: 45 }
                                }
                            }
                        }
                    });
                }
            }

            // Event listeners
            document.getElementById('back-btn').addEventListener('click', showStart);

            const resetBtn = document.getElementById('reset-stats-btn');
            if (resetBtn) {
                resetBtn.addEventListener('click', async () => {
                    if (confirm('Sei sicuro di voler azzerare tutte le statistiche, simulazioni e storico?')) {
                        // Reset all data
                        statsData = { materie: {}, argomenti: {} };
                        simulations = [];
                        projectionHistory = [];
                        wrongIds = [];

                        // Save to localStorage
                        localStorage.setItem(STATS_KEY, JSON.stringify(statsData));
                        localStorage.setItem(SIMULATIONS_KEY, JSON.stringify(simulations));
                        localStorage.setItem(PROJECTION_HISTORY_KEY, JSON.stringify(projectionHistory));
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(wrongIds));

                        // Cancel any pending debounced sync
                        if (syncTimeout) {
                            clearTimeout(syncTimeout);
                            syncTimeout = null;
                        }

                        // Immediate sync to cloud (not debounced)
                        if (currentUser) {
                            await syncToCloud();
                        }

                        showStats();
                    }
                });
            }

            // Tab switching
            document.querySelectorAll('.stats-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.stats-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.stats-tab-content').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    document.getElementById('tab-' + this.dataset.tab).classList.add('active');
                });
            });

            // Simulation card expand/collapse
            document.querySelectorAll('.simulation-card').forEach(card => {
                card.addEventListener('click', function() {
                    this.classList.toggle('expanded');
                });
            });

            const practiceWeakBtn = document.getElementById('practice-weak-btn');
            if (practiceWeakBtn) {
                practiceWeakBtn.addEventListener('click', startWeakAreasQuiz);
            }

            // Toggle argomenti visibility
            document.querySelectorAll('.materia-row').forEach(row => {
                row.style.cursor = 'pointer';
                row.addEventListener('click', function() {
                    const materia = decodeURIComponent(this.dataset.materia);
                    const argList = document.getElementById('arg-' + encodeURIComponent(materia));
                    if (argList) {
                        argList.classList.toggle('expanded');
                    }
                });
            });
        }

        function startWeakAreasQuiz() {
            const weakAreas = getWeakAreas();
            const weakMaterie = new Set();
            const weakArgomenti = new Set();

            weakAreas.forEach(w => {
                if (w.type === 'materia') {
                    weakMaterie.add(w.name);
                } else {
                    weakArgomenti.add(`${w.materia}|||${w.argomento}`);
                }
            });

            // Get questions from weak areas
            let pool = questions.map((q, i) => i).filter(i => {
                const q = questions[i];
                const argKey = `${q.materia}|||${q.argomenti}`;
                return weakMaterie.has(q.materia) || weakArgomenti.has(argKey);
            });

            if (pool.length === 0) {
                alert('Nessuna domanda disponibile per le aree deboli');
                showStart();
                return;
            }

            pool = shuffle(pool).slice(0, Math.min(30, pool.length));
            quiz = { pool, current: 0, correct: 0, wrong: 0, skipped: 0, mistakes: [], mode: 'weak', answers: {} };
            showQuestion();
        }

        function showCustomSetup() {
            selectedMaterie = [];
            render(`
                ${getAuthHeaderHtml()}
                <div class="start-screen">
                    <h1>Quiz Personalizzato</h1>
                    <p class="subtitle">Seleziona le materie da includere</p>
                    <div class="materie-filter">
                        <div class="filter-actions">
                            <button class="btn btn-secondary" id="select-all">Tutte</button>
                            <button class="btn btn-secondary" id="select-none">Nessuna</button>
                        </div>
                        <div class="materie-grid" id="materie-grid" style="margin-top:12px;">
                            ${materie.map(m => `<span class="materia-chip" data-materia="${encodeURIComponent(m)}">${m}</span>`).join('')}
                        </div>
                    </div>
                    <div style="margin-top:24px;">
                        <label style="font-size:0.875rem;">Numero domande: <strong id="num-display">50</strong></label>
                        <input type="range" id="num-slider" min="10" max="140" value="50" style="width:100%;margin-top:8px;">
                    </div>
                    <div class="actions" style="justify-content:center;margin-top:24px;">
                        <button class="btn btn-secondary" id="back-btn">Indietro</button>
                        <button class="btn btn-primary" id="start-custom-btn">Inizia</button>
                    </div>
                </div>
            `);

            const slider = document.getElementById('num-slider');
            const numDisplay = document.getElementById('num-display');
            slider.addEventListener('input', () => numDisplay.textContent = slider.value);

            document.querySelectorAll('.materia-chip').forEach(chip => {
                chip.addEventListener('click', function() {
                    this.classList.toggle('selected');
                    const m = decodeURIComponent(this.dataset.materia);
                    if (this.classList.contains('selected')) {
                        selectedMaterie.push(m);
                    } else {
                        selectedMaterie = selectedMaterie.filter(x => x !== m);
                    }
                });
            });

            document.getElementById('select-all').addEventListener('click', () => {
                selectedMaterie = [...materie];
                document.querySelectorAll('.materia-chip').forEach(c => c.classList.add('selected'));
            });

            document.getElementById('select-none').addEventListener('click', () => {
                selectedMaterie = [];
                document.querySelectorAll('.materia-chip').forEach(c => c.classList.remove('selected'));
            });

            document.getElementById('back-btn').addEventListener('click', showStart);
            document.getElementById('start-custom-btn').addEventListener('click', () => {
                const num = parseInt(slider.value);
                startQuiz('custom', num, selectedMaterie);
            });
        }

        // SSM 2024 distribution - maps actual materia names to question count
        const SSM_DISTRIBUTION = {
            'Cardiologia e Chirurgia Cardiovascolare': 14,
            'Chirurgia Generale': 10,
            'Ginecologia': 9,
            'Anestesia': 9,
            'Neurologia e Neurochirurgia': 7,
            'Pediatria': 7,
            'Ortopedia': 7,
            'Pneumologia e Chirurgia Toracica': 6,
            'Dermatologia': 6,
            'Gastroenterologia': 5,
            'Endocrinologia e Nutrizione': 5,
            'Malattie Infettive e Microbiologia': 5,
            'Radiologia': 5,
            'Statistica, Epidemiologia e SanitÃ  Pubblica': 5,
            'Reumatologia': 5,
            'Urologia': 5,
            'Otorinolaringoiatria': 5,
            'Ematologia': 4,
            'Oncologia': 3,
            'Nefrologia': 3,
            'Psichiatria': 3,
            'Oftalmologia': 2,
            'Medicina del Lavoro': 2,
            'Medicina legale': 2,
            // Extra subjects to reach 140 (not in official SSM but in our database)
            'Immunologia': 2,
            'Genetica': 2,
            'Scienze di base': 2
        };
        // Total: 134 (SSM 2024 official) + 6 (extra) = 140

        function selectSSMQuestions() {
            const selected = [];
            const usedIndices = new Set();

            // For each materia in distribution, select random questions
            Object.entries(SSM_DISTRIBUTION).forEach(([materia, count]) => {
                // Find all questions for this materia
                const materiaQuestions = questions
                    .map((q, i) => ({ q, i }))
                    .filter(({ q, i }) => q.materia === materia && !usedIndices.has(i));

                // Shuffle and take up to 'count' questions
                const shuffled = shuffle(materiaQuestions);
                const toTake = Math.min(count, shuffled.length);

                for (let j = 0; j < toTake; j++) {
                    selected.push(shuffled[j].i);
                    usedIndices.add(shuffled[j].i);
                }
            });

            // If we don't have 140, fill with random questions from any subject
            if (selected.length < 140) {
                const remaining = questions
                    .map((q, i) => i)
                    .filter(i => !usedIndices.has(i));
                const shuffledRemaining = shuffle(remaining);
                const needed = 140 - selected.length;
                for (let j = 0; j < Math.min(needed, shuffledRemaining.length); j++) {
                    selected.push(shuffledRemaining[j]);
                }
            }

            // Shuffle final selection so materie are mixed
            return shuffle(selected);
        }

        function startQuiz(mode, customNum = 0, customMaterie = []) {
            let pool;
            if (mode === '140') {
                pool = selectSSMQuestions();
            } else if (mode === '20') {
                pool = shuffle(questions.map((q, i) => i)).slice(0, 20);
            } else if (mode === 'wrong') {
                pool = shuffle(wrongIds.slice());
            } else if (mode === 'custom') {
                let filtered = questions.map((q, i) => i);
                if (customMaterie.length > 0) {
                    filtered = filtered.filter(i => customMaterie.includes(questions[i].materia));
                }
                pool = shuffle(filtered).slice(0, Math.min(customNum, filtered.length));
            }

            if (pool.length === 0) {
                alert('Nessuna domanda disponibile per i criteri selezionati');
                showStart();
                return;
            }

            const startTime = mode === '140' ? Date.now() : null;
            const endTime = mode === '140' ? Date.now() + (210 * 60 * 1000) : null; // 210 minutes
            quiz = { pool, current: 0, correct: 0, wrong: 0, skipped: 0, mistakes: [], mode, startTime, endTime, answers: {} };
            showQuestion();
        }

        function formatTime(ms) {
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!quiz || !quiz.endTime) return;
            const remaining = quiz.endTime - Date.now();
            const timerEl = document.getElementById('timer');
            if (timerEl) {
                timerEl.textContent = formatTime(remaining);
                timerEl.className = 'timer';
                if (remaining < 10 * 60 * 1000) timerEl.className = 'timer danger'; // < 10 min
                else if (remaining < 30 * 60 * 1000) timerEl.className = 'timer warning'; // < 30 min
            }
            if (remaining <= 0) {
                clearInterval(timerInterval);
                alert('Tempo scaduto! Il quiz verrÃ  terminato.');
                if (quiz.mode === 'shared') {
                    finishSharedQuiz();
                } else {
                    finishSSMQuiz();
                }
            }
        }

        function showQuestion() {
            const idx = quiz.pool[quiz.current];
            const q = questions[idx];
            const total = quiz.pool.length;
            const progress = ((quiz.current + 1) / total * 100).toFixed(0);
            const isSSM = quiz.mode === '140' || quiz.mode === 'shared';

            // For SSM, use stored order or create new shuffled order
            if (!quiz.questionOptions) quiz.questionOptions = {};
            if (!quiz.questionOptions[idx]) {
                quiz.questionOptions[idx] = shuffle(q.risposte.slice());
            }
            const opts = isSSM ? quiz.questionOptions[idx] : shuffle(q.risposte.slice());

            // Get previously selected answer for this question (SSM mode)
            const previousAnswer = quiz.answers ? quiz.answers[idx] : null;

            // Count answered questions for SSM
            const answeredCount = quiz.answers ? Object.keys(quiz.answers).length : 0;

            // Start timer for SSM (only if there's a time limit)
            if (isSSM && quiz.endTime && !timerInterval) {
                timerInterval = setInterval(updateTimer, 1000);
            }

            const statsHtml = isSSM
                ? `<span>${quiz.current + 1} / ${total}</span> Â· <span>${answeredCount} risposte date</span>`
                : `<span>${quiz.current + 1} / ${total}</span> Â· <span>${quiz.correct} corrette</span>`;

            render(`
                <header>
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <h1>${quiz.mode === 'shared' ? 'Sessione Condivisa' : 'Simulatore SSM'} <span class="materia-tag">${q.materia}</span></h1>
                        ${isSSM && quiz.endTime ? `<div id="timer" class="timer">${formatTime(quiz.endTime - Date.now())}</div>` : ''}
                    </div>
                    <div class="stats">${statsHtml}</div>
                    <div class="progress-bar"><div class="progress-fill" style="width:${progress}%"></div></div>
                </header>
                <div class="question-card">
                    <div class="question-number">Domanda ${quiz.current + 1}</div>
                    <div class="question-text">${q.domanda}</div>
                    ${q.has_image && q.image_src ? `<div class="question-image"><img src="${q.image_src}" alt="Immagine domanda" onclick="openModal(this.src)"></div>` : ''}
                    <div class="options" id="options">
                        ${opts.map(o => `<button class="option ${previousAnswer === o.id ? 'selected' : ''}" data-id="${o.id}" data-correct="${o.isCorrect}">${o.text}</button>`).join('')}
                    </div>
                    <div class="feedback" id="feedback"></div>
                    <div class="commento" id="commento"></div>
                </div>
                <div class="modal" id="modal" onclick="closeModal()">
                    <span class="modal-close">&times;</span>
                    <img id="modal-img" src="" alt="Immagine ingrandita">
                </div>
                <div class="actions">
                    ${isSSM ? `
                        <button class="btn btn-secondary" id="prev-btn" ${quiz.current === 0 ? 'disabled' : ''}>â Precedente</button>
                        <button class="btn btn-secondary" id="next-btn">${quiz.current < total - 1 ? 'Successiva â' : 'Vai ai risultati'}</button>
                        <button class="btn btn-primary" id="submit-btn">Termina esame</button>
                        <button class="btn btn-danger btn-small" id="quit-btn" style="margin-left:auto;">Abbandona</button>
                    ` : `
                        <button class="btn btn-primary hidden" id="next-btn">${quiz.current < total - 1 ? 'Prossima' : 'Risultati'}</button>
                        <button class="btn btn-secondary" id="quit-btn">Esci</button>
                    `}
                </div>
                ${isSSM ? `
                <div style="margin-top:16px;display:flex;flex-wrap:wrap;gap:4px;justify-content:center;">
                    ${quiz.pool.map((_, i) => {
                        const isAnswered = quiz.answers && quiz.answers[quiz.pool[i]] !== undefined;
                        const isCurrent = i === quiz.current;
                        return `<button class="question-nav-btn ${isCurrent ? 'current' : ''} ${isAnswered ? 'answered' : ''}" data-index="${i}">${i + 1}</button>`;
                    }).join('')}
                </div>
                ` : ''}
            `);

            // Event listeners
            document.querySelectorAll('.option').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (isSSM) {
                        handleSSMAnswer(btn, idx);
                    } else {
                        handleAnswer(btn, idx, q);
                    }
                });
            });

            if (isSSM) {
                document.getElementById('prev-btn')?.addEventListener('click', () => {
                    if (quiz.current > 0) { quiz.current--; showQuestion(); }
                });
                document.getElementById('next-btn')?.addEventListener('click', () => {
                    if (quiz.current < total - 1) { quiz.current++; showQuestion(); }
                    else { document.getElementById('submit-btn').click(); }
                });
                document.getElementById('submit-btn')?.addEventListener('click', () => {
                    const unanswered = total - Object.keys(quiz.answers || {}).length;
                    const finishFn = quiz.mode === 'shared' ? finishSharedQuiz : finishSSMQuiz;
                    if (unanswered > 0) {
                        if (confirm(`Hai ${unanswered} domande senza risposta. Vuoi terminare comunque?`)) {
                            finishFn();
                        }
                    } else {
                        finishFn();
                    }
                });
                document.getElementById('quit-btn')?.addEventListener('click', async () => {
                    if (confirm('Sei sicuro di voler abbandonare? I tuoi progressi andranno persi.')) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                        if (quiz.mode === 'shared' && sharedSession) {
                            await leaveSession();
                        } else {
                            showStart();
                        }
                    }
                });
                document.querySelectorAll('.question-nav-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        quiz.current = parseInt(btn.dataset.index);
                        showQuestion();
                    });
                });
            } else {
                document.getElementById('quit-btn')?.addEventListener('click', showStart);
            }
        }

        function handleSSMAnswer(btn, qIdx) {
            // Just select/deselect, no feedback
            const selectedId = parseInt(btn.dataset.id);

            // If clicking same answer, deselect it
            if (quiz.answers[qIdx] === selectedId) {
                delete quiz.answers[qIdx];
            } else {
                quiz.answers[qIdx] = selectedId;
            }

            // Update UI
            document.querySelectorAll('.option').forEach(b => {
                b.classList.remove('selected');
                if (parseInt(b.dataset.id) === quiz.answers[qIdx]) {
                    b.classList.add('selected');
                }
            });

            // Update answered count in header
            const answeredCount = Object.keys(quiz.answers).length;
            const statsEl = document.querySelector('.stats');
            if (statsEl) {
                statsEl.innerHTML = `<span>${quiz.current + 1} / ${quiz.pool.length}</span> Â· <span>${answeredCount} risposte date</span>`;
            }

            // Update nav buttons
            document.querySelectorAll('.question-nav-btn').forEach(navBtn => {
                const i = parseInt(navBtn.dataset.index);
                const isAnswered = quiz.answers[quiz.pool[i]] !== undefined;
                navBtn.classList.toggle('answered', isAnswered);
            });
        }

        function finishSSMQuiz() {
            clearInterval(timerInterval);
            timerInterval = null;

            // Calculate subject breakdown
            const subjectBreakdown = {};

            // Calculate results
            quiz.pool.forEach((qIdx, i) => {
                const q = questions[qIdx];
                const answer = quiz.answers[qIdx];

                // Initialize subject breakdown
                if (!subjectBreakdown[q.materia]) {
                    subjectBreakdown[q.materia] = { correct: 0, wrong: 0, skipped: 0 };
                }

                if (answer === undefined) {
                    quiz.skipped++;
                    subjectBreakdown[q.materia].skipped++;
                } else {
                    const selectedOption = q.risposte.find(r => r.id === answer);
                    if (selectedOption && selectedOption.isCorrect) {
                        quiz.correct++;
                        subjectBreakdown[q.materia].correct++;
                    } else {
                        quiz.wrong++;
                        subjectBreakdown[q.materia].wrong++;
                        quiz.mistakes.push({
                            domanda: q.domanda,
                            materia: q.materia,
                            argomento: q.argomenti,
                            tua: selectedOption ? selectedOption.text : 'N/A',
                            corretta: q.risposta_corretta_text,
                            commento: q.commento,
                            has_image: q.has_image,
                            image_src: q.image_src
                        });
                        if (!wrongIds.includes(qIdx)) { wrongIds.push(qIdx); saveWrong(); }
                    }

                    // Record stats for answered questions
                    const isCorrect = selectedOption && selectedOption.isCorrect;
                    recordAnswer(q.materia, q.argomenti, isCorrect);
                }
            });

            // Calculate duration
            const durationMs = Date.now() - quiz.startTime;
            const durationMin = Math.round(durationMs / 60000);

            // Save simulation result
            const ssmScore = quiz.correct * 1 + quiz.wrong * (-0.25);
            const simulationResult = {
                id: quiz.startTime, // Use start time as unique ID
                date: new Date(quiz.startTime).toISOString(),
                score: ssmScore,
                correct: quiz.correct,
                wrong: quiz.wrong,
                skipped: quiz.skipped,
                total: quiz.pool.length,
                duration: durationMin,
                subjectBreakdown: subjectBreakdown
            };
            addSimulation(simulationResult);

            // Record projected score for trend tracking
            recordProjectedScore();

            showResults();
        }

        function handleSkip(qIdx, q) {
            quiz.skipped++;

            // Hide skip button, show next
            const skipBtn = document.getElementById('skip-btn');
            if (skipBtn) skipBtn.classList.add('hidden');

            const feedback = document.getElementById('feedback');
            feedback.classList.add('visible');
            feedback.style.background = '#f5f5f5';
            feedback.style.color = '#666';
            feedback.textContent = 'Domanda saltata (0 punti)';

            // Show correct answer
            document.querySelectorAll('.option').forEach(b => {
                b.classList.add('disabled');
                if (b.dataset.correct === 'true') {
                    b.classList.add('show-correct');
                }
            });

            if (q.commento) {
                const commento = document.getElementById('commento');
                commento.classList.add('visible');
                commento.innerHTML = '<strong>Spiegazione:</strong> ' + q.commento;
            }

            const nextBtn = document.getElementById('next-btn');
            nextBtn.classList.remove('hidden');
            nextBtn.addEventListener('click', () => {
                if (quiz.current < quiz.pool.length - 1) {
                    quiz.current++;
                    showQuestion();
                } else {
                    showResults();
                }
            });
        }

        function handleAnswer(btn, qIdx, q) {
            if (btn.classList.contains('disabled')) return;

            const isCorrect = btn.dataset.correct === 'true';
            const userAnswer = btn.textContent;

            // Record stats
            recordAnswer(q.materia, q.argomenti, isCorrect);

            // Hide skip button if present
            const skipBtn = document.getElementById('skip-btn');
            if (skipBtn) skipBtn.classList.add('hidden');

            document.querySelectorAll('.option').forEach(b => {
                b.classList.add('disabled');
                if (b.dataset.correct === 'true') {
                    b.classList.add(isCorrect ? 'correct' : 'show-correct');
                }
            });

            if (isCorrect) {
                btn.classList.add('correct');
                quiz.correct++;
                const wIdx = wrongIds.indexOf(qIdx);
                if (wIdx > -1) { wrongIds.splice(wIdx, 1); saveWrong(); }
            } else {
                btn.classList.add('wrong');
                quiz.wrong++;
                quiz.mistakes.push({
                    domanda: q.domanda,
                    materia: q.materia,
                    argomento: q.argomenti,
                    tua: userAnswer,
                    corretta: q.risposta_corretta_text,
                    commento: q.commento,
                    has_image: q.has_image,
                    image_src: q.image_src
                });
                if (!wrongIds.includes(qIdx)) { wrongIds.push(qIdx); saveWrong(); }
            }

            const feedback = document.getElementById('feedback');
            feedback.classList.add('visible', isCorrect ? 'correct' : 'wrong');
            const isSSM = quiz.mode === '140';
            if (isCorrect) {
                feedback.textContent = isSSM ? 'Corretto! (+1 punto)' : 'Corretto!';
            } else {
                feedback.textContent = isSSM
                    ? `Sbagliato (-0.25 punti). ${q.risposta_corretta_text}`
                    : `Sbagliato. ${q.risposta_corretta_text}`;
            }

            if (q.commento) {
                const commento = document.getElementById('commento');
                commento.classList.add('visible');
                commento.innerHTML = '<strong>Spiegazione:</strong> ' + q.commento;
            }

            const nextBtn = document.getElementById('next-btn');
            nextBtn.classList.remove('hidden');
            nextBtn.addEventListener('click', () => {
                if (quiz.current < quiz.pool.length - 1) {
                    quiz.current++;
                    showQuestion();
                } else {
                    showResults();
                }
            });
        }

        function showResults() {
            const total = quiz.pool.length;
            const isSSM = quiz.mode === '140';

            // Record projected score for non-SSM modes (SSM already records in finishSSMQuiz)
            if (!isSSM) {
                recordProjectedScore();
            }

            // SSM scoring: +1 correct, -0.25 wrong, 0 skipped
            const ssmScore = quiz.correct * 1 + quiz.wrong * (-0.25);
            const maxScore = total; // Max possible is all correct
            const pct = Math.round(quiz.correct / total * 100);

            let reviewHtml = '';
            if (quiz.mistakes.length > 0) {
                reviewHtml = `
                    <div class="review-section">
                        <h3>Da ripassare (${quiz.mistakes.length})</h3>
                        ${quiz.mistakes.map(m => `
                            <div class="review-item">
                                <div class="review-materia">${m.materia} â ${m.argomento}</div>
                                <div class="review-question">${m.domanda}</div>
                                ${m.has_image && m.image_src ? `<div class="review-image"><img src="${m.image_src}" alt="Immagine"></div>` : ''}
                                <div class="review-your">Hai risposto: ${m.tua}</div>
                                <div class="review-correct">Corretta: ${m.corretta}</div>
                                ${m.commento ? `<div class="review-commento">${m.commento}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            const scoreDisplay = isSSM
                ? `<div class="score">${ssmScore.toFixed(2)}</div><div class="score-label">Punteggio SSM su ${maxScore}</div>`
                : `<div class="score">${pct}%</div><div class="score-label">Punteggio finale</div>`;

            const breakdownHtml = isSSM
                ? `<div class="results-breakdown">
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#22863a;">+${quiz.correct}</div><div class="breakdown-label">Corrette (+1)</div></div>
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#cb2431;">${quiz.wrong > 0 ? '-' + (quiz.wrong * 0.25).toFixed(2) : '0'}</div><div class="breakdown-label">Errate (-0.25)</div></div>
                        <div class="breakdown-item"><div class="breakdown-value" style="color:#888;">${quiz.skipped}</div><div class="breakdown-label">Omesse (0)</div></div>
                    </div>`
                : `<div class="results-breakdown">
                        <div class="breakdown-item"><div class="breakdown-value">${quiz.correct}</div><div class="breakdown-label">Corrette</div></div>
                        <div class="breakdown-item"><div class="breakdown-value">${quiz.wrong}</div><div class="breakdown-label">Errate</div></div>
                        <div class="breakdown-item"><div class="breakdown-value">${total}</div><div class="breakdown-label">Totali</div></div>
                    </div>`;

            render(`
                ${getAuthHeaderHtml()}
                <div class="results">
                    <h2>Risultati${isSSM ? ' Simulazione SSM' : ''}</h2>
                    ${scoreDisplay}
                    ${breakdownHtml}
                    <div class="actions" style="justify-content:center;">
                        <button class="btn btn-primary" id="restart-btn">Nuovo quiz</button>
                        <button class="btn btn-secondary" id="stats-btn">Statistiche</button>
                        <button class="btn btn-secondary" id="home-btn">Menu</button>
                    </div>
                    ${reviewHtml}
                </div>
            `);

            document.getElementById('restart-btn').addEventListener('click', () => startQuiz('20'));
            document.getElementById('stats-btn').addEventListener('click', showStats);
            document.getElementById('home-btn').addEventListener('click', showStart);
        }

        // Load JSONL
        fetch('domande_unite_no_duplicati.jsonl')
            .then(r => {
                if (!r.ok) throw new Error();
                return r.text();
            })
            .then(text => {
                const lines = text.trim().split('\n').filter(l => l.trim());
                questions = lines.map((line, i) => {
                    const q = JSON.parse(line);
                    q._idx = i;
                    return q;
                });
                materie = [...new Set(questions.map(q => q.materia))].sort();

                // Build argomenti map
                questions.forEach(q => {
                    if (!argomenti[q.materia]) argomenti[q.materia] = new Set();
                    argomenti[q.materia].add(q.argomenti);
                });

                loadStats();
                initAuth().then(() => showStart());
            })
            .catch(() => {
                render(`
                    <div class="error-screen">
                        <p>Impossibile caricare le domande</p>
                        <button class="btn btn-primary" onclick="location.reload()">Riprova</button>
                    </div>
                `);
            });
    })();
    </script>
</body>
</html>
